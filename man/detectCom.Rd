% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/detectCom.R
\name{detectCom}
\alias{detectCom}
\title{Community detection in multilayer networks (multinet)}
\usage{
detectCom(
  net,
  method = c("glouvain", "louvain", "infomap", "clique", "abacus"),
  supra_graph = FALSE,
  layers = NULL,
  min.actors = 15,
  min.layers = 2,
  relabel_by_size = TRUE,
  seed = NULL,
  glouvain_gamma = 1,
  glouvain_omega = 1,
  clique.k = 3,
  clique.m = 1,
  infomap_overlapping = FALSE,
  infomap_directed = FALSE,
  infomap_self_links = TRUE,
  edgeWeight = c("count", "sum"),
  results_dir = getOption("mlnet.results_dir", "omicsDNA_results"),
  save_to_rds = TRUE,
  rds_file = NULL,
  write_csv = FALSE,
  csv_prefix = "communities",
  write_summary_csv = TRUE,
  verbose = TRUE
)
}
\arguments{
\item{net}{A multilayer network of class \code{multinet::ml.network}.}

\item{method}{Community detection method. One of:
\itemize{
\item \code{"glouvain"} (default): generalized Louvain
\item \code{"infomap"}
\item \code{"clique"} (k-clique percolation in multilayer mode; k-clique union in supra mode)
\item \code{"abacus"}
\item \code{"louvain"} is accepted as an alias of \code{"glouvain"}.
}}

\item{supra_graph}{Logical. If \code{FALSE} (default), run multilayer-native
\verb{multinet::*_ml()} algorithms. If \code{TRUE}, collapse layers into a single
supra-graph and run an \code{igraph} method (\code{glouvain}, \code{infomap}, or \code{clique}).}

\item{layers}{Optional character vector of layer names to include.
If \code{NULL}, all layers are used.}

\item{min.actors}{Minimum number of unique actors required to keep a community.
Applied as a post-filter to all methods.}

\item{min.layers}{Minimum number of layers required for a community to be kept.
Applied as a post-filter to all methods.}

\item{relabel_by_size}{Logical. If \code{TRUE} (default), relabel communities as
\verb{C1, C2, ...} ordered by decreasing community size.}

\item{seed}{Optional integer seed for reproducibility. When provided, this
function calls \code{set.seed(seed)} before invoking algorithms that may be
non-deterministic.}

\item{glouvain_gamma}{Resolution parameter passed to \code{multinet::glouvain_ml()}
when \code{method = "glouvain"} and \code{supra_graph = FALSE}.}

\item{glouvain_omega}{Inter-layer coupling parameter passed to
\code{multinet::glouvain_ml()} when \code{method = "glouvain"} and \code{supra_graph = FALSE}.}

\item{clique.k}{Clique size threshold.
\itemize{
\item In multilayer mode (\code{supra_graph = FALSE}), passed as \code{k} to
\code{multinet::clique_percolation_ml()} (must be >= 3).
\item In supra-graph mode (\code{supra_graph = TRUE}), used as the minimum clique size
in \code{igraph::cliques()}.
}}

\item{clique.m}{Multilayer-only parameter passed as \code{m} to
\code{multinet::clique_percolation_ml()} when \code{supra_graph = FALSE}.
Ignored when \code{supra_graph = TRUE}.}

\item{infomap_overlapping}{Passed to \code{multinet::infomap_ml()} when
\code{method = "infomap"} and \code{supra_graph = FALSE}.}

\item{infomap_directed}{Passed to \code{multinet::infomap_ml()} when
\code{method = "infomap"} and \code{supra_graph = FALSE}.}

\item{infomap_self_links}{Passed to \code{multinet::infomap_ml()} when
\code{method = "infomap"} and \code{supra_graph = FALSE}.}

\item{edgeWeight}{How to aggregate edge weights across layers when
\code{supra_graph = TRUE}. One of \code{"count"} or \code{"sum"}. Ignored when
\code{supra_graph = FALSE}.}

\item{results_dir}{Output directory for optional files.}

\item{save_to_rds}{Logical; save the community table to an RDS file.}

\item{rds_file}{Optional RDS filename. If relative, it is created inside
\code{results_dir}. If \code{NULL}, a timestamped name is generated.}

\item{write_csv}{Logical; write the community table to CSV.}

\item{csv_prefix}{Prefix used for CSV and summary CSV files.}

\item{write_summary_csv}{Logical; write a small community summary CSV
(community id, size, span).}

\item{verbose}{Logical; print progress messages.}
}
\value{
A data frame with columns:
\itemize{
\item \code{actor}: actor (gene) identifier
\item \code{com}: community identifier (\code{C1}, \code{C2}, ... if relabeled)
\item \code{layer}: layer name
\item \code{method}: method used (e.g. \code{"glouvain"})
}

with attributes \code{community_sizes}, \code{layer_span}, and \code{files}.
}
\description{
Detect communities in a \code{multinet::ml.network} using either:
\itemize{
\item \strong{Multilayer-native algorithms from the \code{multinet} package} (default,
\code{supra_graph = FALSE}):
\itemize{
\item \code{multinet::glouvain_ml()}
\item \code{multinet::infomap_ml()}
\item \code{multinet::clique_percolation_ml()}
\item \code{multinet::abacus_ml()}
}
\item A \strong{layer-collapsed supra-graph approach} (\code{supra_graph = TRUE}) for
\code{method = "glouvain"}, \code{"infomap"}, or \code{"clique"}.
}

This function standardizes outputs to a tidy edge-independent table and keeps
the output structure compatible with downstream analysis:
\itemize{
\item Columns: \code{actor}, \code{com}, \code{layer}, \code{method}
\item Attributes:
\itemize{
\item \code{community_sizes}: named integer vector (# unique actors per community)
\item \code{layer_span}: named integer vector (# layers per community)
\item \code{files}: list of written file paths (\code{rds}, \code{csv}, \code{summary_csv})
}
}
}
\details{
\subsection{Multilayer-native mode (\code{supra_graph = FALSE})}{

The community assignment is computed by calling the corresponding
\verb{multinet::*_ml()} function \strong{directly}. Therefore, if you call:

\if{html}{\out{<div class="sourceCode r">}}\preformatted{comm1 <- multinet::glouvain_ml(net, gamma = 1, omega = 1)
comm2 <- detectCom(net, method = "glouvain",
                   supra_graph = FALSE,
                   glouvain_gamma = 1,
                   glouvain_omega = 1,
                   min.actors = 1,
                   min.layers = 1,
                   relabel_by_size = FALSE)
}\if{html}{\out{</div>}}

then \code{comm1} and \code{comm2} will represent the \strong{same partition} (up to
community identifier naming), because \code{detectCom()} delegates to
\code{multinet::glouvain_ml()} with the same parameters.
}

\subsection{Supra-graph mode (\code{supra_graph = TRUE})}{

The function first \strong{collapses} the selected layers into a single undirected
graph (the \emph{supra-graph}), then runs an \code{igraph} community method on that
collapsed graph:
\itemize{
\item \code{method = "glouvain"}  -> \code{igraph::cluster_louvain()}
\item \code{method = "infomap"}   -> \code{igraph::cluster_infomap()}
\item \code{method = "clique"}    -> k-clique union components (based on
\code{igraph::cliques()} + \code{igraph::components()})
}

Community membership is then \strong{mapped back} to each layer.

The \code{edgeWeight} argument controls how supra-graph edge weights are
constructed across layers:
\itemize{
\item \code{"count"}: the supra-edge weight equals the number of layers in which the
pair appears at least once.
\item \code{"sum"}: the supra-edge weight equals the sum of per-layer edge weights.
}
}

\subsection{Filtering and relabeling}{

After any method finishes, communities are retained only if:
\itemize{
\item \verb{#unique_actors >= min.actors}, and
\item \verb{#layers_present >= min.layers}.
}

If \code{relabel_by_size = TRUE}, communities are relabeled \verb{C1, C2, ...} ordered by
decreasing community size (ties broken arbitrarily).
}
}
\examples{
# -------------------------------------------------------------------------
# Minimal reproducible examples using igraph objects (one graph per layer)
# -------------------------------------------------------------------------

# Build a tiny 2-layer multiplex from igraph graphs
g1 <- igraph::graph_from_data_frame(
  data.frame(from = c("a","b","c"), to = c("b","c","d"), w_ = c(1,1,1)),
  directed = FALSE
)
g2 <- igraph::graph_from_data_frame(
  data.frame(from = c("a","a","d"), to = c("c","d","e"), w_ = c(1,1,1)),
  directed = FALSE
)

net <- multinet::ml_empty()
multinet::add_igraph_layer_ml(net, g1, name = "E1")
multinet::add_igraph_layer_ml(net, g2, name = "E2")

# -------------------------
# GLouvain (multinet) mode
# -------------------------
comm_gl_mn <- detectCom(
  net,
  method         = "glouvain",
  supra_graph    = FALSE,
  glouvain_gamma = 1,
  glouvain_omega = 1,
  min.actors     = 1,
  min.layers     = 1,
  relabel_by_size = FALSE,
  seed           = 1,
  save_to_rds    = FALSE
)

# Direct call (should match the same partition, up to naming)
comm_gl_direct <- multinet::glouvain_ml(net, gamma = 1, omega = 1)

# -------------------------
# GLouvain (supra-graph) mode
# -------------------------
comm_gl_supra <- detectCom(
  net,
  method      = "glouvain",
  supra_graph = TRUE,
  edgeWeight  = "count",
  min.actors  = 1,
  min.layers  = 1,
  seed        = 1,
  save_to_rds = FALSE
)

# -------------------------
# Clique percolation (multinet) mode: clique.k + clique.m
# -------------------------
comm_clq_mn <- detectCom(
  net,
  method      = "clique",
  supra_graph = FALSE,
  clique.k    = 3,
  clique.m    = 1,
  min.actors  = 1,
  min.layers  = 1,
  save_to_rds = FALSE
)

# -------------------------
# Clique (supra-graph) mode: clique.m ignored
# -------------------------
comm_clq_supra <- detectCom(
  net,
  method      = "clique",
  supra_graph = TRUE,
  clique.k    = 3,
  edgeWeight  = "count",
  min.actors  = 1,
  min.layers  = 1,
  save_to_rds = FALSE
)

# -------------------------
# Infomap (multinet) mode: infomap_* parameters
# -------------------------
comm_info_mn <- detectCom(
  net,
  method              = "infomap",
  supra_graph         = FALSE,
  infomap_overlapping = FALSE,
  infomap_directed    = FALSE,
  infomap_self_links  = TRUE,
  min.actors          = 1,
  min.layers          = 1,
  seed                = 1,
  save_to_rds         = FALSE
)

# -------------------------
# Infomap (supra-graph) mode
# -------------------------
comm_info_supra <- detectCom(
  net,
  method      = "infomap",
  supra_graph = TRUE,
  edgeWeight  = "sum",
  min.actors  = 1,
  min.layers  = 1,
  seed        = 1,
  save_to_rds = FALSE
)

# -------------------------
# ABACUS (multinet) mode
# -------------------------
comm_abacus <- detectCom(
  net,
  method      = "abacus",
  supra_graph = FALSE,
  min.actors  = 1,
  min.layers  = 1,
  save_to_rds = FALSE
)

# -------------------------------------------------------------------------
# Example using an existing list of igraph objects on disk (your workflow)
# -------------------------------------------------------------------------
\dontrun{
setwd("~/Abir/test_data1/")
load("igraph_objects.RData")  # loads graph_list_A

# Build ml.network from your igraph list (any equivalent builder works)
net_A <- multinet::ml_empty()
for (ln in names(graph_list_A)) {
  g <- graph_list_A[[ln]]
  # OPTIONAL: if you want weighted glouvain in multinet, ensure edge attr w_ exists:
  # igraph::E(g)$w_ <- igraph::E(g)$correlation
  multinet::add_igraph_layer_ml(net_A, g, name = ln)
}

# Multilayer glouvain (multinet)
comm_ml <- detectCom(net_A, method = "glouvain",
                     supra_graph = FALSE,
                     glouvain_gamma = 1,
                     glouvain_omega = 1,
                     min.actors = 15,
                     min.layers = 2,
                     seed = 1)

# Direct call (compare partitions; labels may differ if relabel_by_size=TRUE)
comm_direct <- multinet::glouvain_ml(net_A, gamma = 1, omega = 1)

# Supra-graph glouvain (legacy-style collapse)
comm_supra <- detectCom(net_A, method = "glouvain",
                        supra_graph = TRUE,
                        edgeWeight  = "count",
                        min.actors  = 15,
                        min.layers  = 2,
                        seed        = 1)
}

}
