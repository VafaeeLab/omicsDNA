% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/detectCom.R
\name{detectCom}
\alias{detectCom}
\title{Community detection in multilayer networks (multinet)}
\usage{
detectCom(
  net,
  method = c("glouvain", "louvain", "infomap", "clique", "abacus"),
  supra_graph = FALSE,
  layers = NULL,
  min.actors = 15,
  min.layers = 2,
  relabel_by_size = TRUE,
  seed = NULL,
  glouvain_gamma = 1,
  glouvain_omega = 1,
  clique.k = 3,
  clique.m = 1,
  infomap_overlapping = FALSE,
  infomap_directed = FALSE,
  infomap_self_links = TRUE,
  edgeWeight = c("count", "sum"),
  results_dir = getOption("mlnet.results_dir", "omicsDNA_results"),
  save_to_rds = TRUE,
  rds_file = NULL,
  write_csv = FALSE,
  csv_prefix = "communities",
  write_summary_csv = TRUE,
  verbose = TRUE
)
}
\arguments{
\item{net}{A multilayer network of class \link[multinet:ml.network]{multinet::ml.network}.}

\item{method}{Community detection method. One of:
\itemize{
\item \code{"glouvain"} (default): generalized Louvain
\item \code{"infomap"}: Infomap community detection
\item \code{"clique"}: clique-based communities
\itemize{
\item multilayer-native mode: k-clique percolation via \code{multinet}
\item supra-graph mode: clique-union components via \code{igraph}
}
\item \code{"abacus"}: ABACUS multilayer community detection (multilayer-native only)
\item \code{"louvain"} is accepted as an alias of \code{"glouvain"} (deprecated; converted
internally with a warning).
}}

\item{supra_graph}{Logical.
\itemize{
\item \code{FALSE} (default): \strong{multilayer-native} algorithms from \code{multinet} are used.
\item \code{TRUE}: layers are collapsed into a single supra-graph and an \code{igraph}
method is used (only for \code{method = "glouvain"}, \code{"infomap"}, \code{"clique"}).
}}

\item{layers}{Optional character vector of layer names to include.
\itemize{
\item If \code{NULL}, all layers are used.
\item If provided, only those layers (intersected with available layers) are used.
}}

\item{min.actors}{Integer (>= 1). Minimum number of \strong{unique actors} required
for a community to be kept. Applied as a post-filter to all methods.}

\item{min.layers}{Integer (>= 1). Minimum number of \strong{distinct layers}
required for a community to be kept. Applied as a post-filter to all methods.}

\item{relabel_by_size}{Logical.
\itemize{
\item \code{TRUE} (default): relabel communities as \code{"C1"}, \code{"C2"}, ... ordered by
decreasing community size.
\item \code{FALSE}: keep the algorithm’s original community ids (converted to character).
}}

\item{seed}{Optional integer. If supplied, \code{set.seed(seed)} is called before
running algorithms that may be stochastic.
\itemize{
\item In multilayer-native mode: used for \code{"glouvain"} and \code{"infomap"}.
\item In supra-graph mode: used before the \code{igraph} clustering step.
}}

\item{glouvain_gamma}{Numeric (> 0). Resolution parameter passed to
\code{\link[multinet:Communities]{multinet::glouvain_ml()}} \strong{only when} \code{method = "glouvain"} and
\code{supra_graph = FALSE}. Ignored otherwise.}

\item{glouvain_omega}{Numeric (>= 0). Inter-layer coupling parameter passed to
\code{\link[multinet:Communities]{multinet::glouvain_ml()}} \strong{only when} \code{method = "glouvain"} and
\code{supra_graph = FALSE}. Ignored otherwise.}

\item{clique.k}{Integer (>= 3). Clique size threshold.
\itemize{
\item Multilayer-native mode (\code{supra_graph = FALSE}): forwarded as \code{k} to
\code{\link[multinet:Communities]{multinet::clique_percolation_ml()}}.
\item Supra-graph mode (\code{supra_graph = TRUE}): used as the minimum clique size in
\code{\link[igraph:cliques]{igraph::cliques()}}.
}}

\item{clique.m}{Integer (>= 1). Multilayer-only clique parameter forwarded as
\code{m} to \code{\link[multinet:Communities]{multinet::clique_percolation_ml()}} \strong{only when}
\code{method = "clique"} and \code{supra_graph = FALSE}. Ignored in supra-graph mode.}

\item{infomap_overlapping}{Logical. Passed to \code{\link[multinet:Communities]{multinet::infomap_ml()}} as
\code{overlapping} \strong{only when} \code{method = "infomap"} and \code{supra_graph = FALSE}.
Ignored in supra-graph mode.}

\item{infomap_directed}{Logical. Passed to \code{\link[multinet:Communities]{multinet::infomap_ml()}} as
\code{directed} \strong{only when} \code{method = "infomap"} and \code{supra_graph = FALSE}.
Ignored in supra-graph mode.}

\item{infomap_self_links}{Logical. Passed to \code{\link[multinet:Communities]{multinet::infomap_ml()}} as
\code{self.links} \strong{only when} \code{method = "infomap"} and \code{supra_graph = FALSE}.
Ignored in supra-graph mode.}

\item{edgeWeight}{How to aggregate edge weights across layers in supra-graph mode.
One of \code{"count"} or \code{"sum"}.
\itemize{
\item \code{"count"}: weight = number of layers in which the edge appears at least once
\item \code{"sum"}: weight = sum of per-layer weights across layers (when available)
Ignored when \code{supra_graph = FALSE}.
}}

\item{results_dir}{Output directory for optional files (RDS/CSV/summary CSV).
If it does not exist, it is created. Defaults to
\code{getOption("mlnet.results_dir", "omicsDNA_results")}.}

\item{save_to_rds}{Logical. If \code{TRUE}, saves the community membership table as
an \code{.rds} file in \code{results_dir} (unless \code{rds_file} is absolute).}

\item{rds_file}{Optional character filename for the RDS output.
\itemize{
\item If \code{NULL}, a timestamped filename is generated automatically.
\item If relative, it is created inside \code{results_dir}.
\item If absolute, it is used as-is.
}}

\item{write_csv}{Logical. If \code{TRUE}, writes the membership table to a CSV file.}

\item{csv_prefix}{Character prefix used to build output CSV filenames.}

\item{write_summary_csv}{Logical. If \code{TRUE}, writes a small summary CSV with:
\code{com}, \code{size} (unique actors), \code{span} (layers).}

\item{verbose}{Logical. If \code{TRUE}, prints progress messages and file paths.}
}
\value{
A data frame with columns \code{actor}, \code{com}, \code{layer}, \code{method}, plus
attributes \code{community_sizes}, \code{layer_span}, and \code{files}.
}
\description{
Detect communities in a multilayer network of class \link[multinet:ml.network]{multinet::ml.network}.

This function supports \strong{two analysis modes}:
\enumerate{
\item \strong{Multilayer-native mode} (\code{supra_graph = FALSE}, default): calls a
multilayer community algorithm from the \strong{\code{multinet}} package directly:
\itemize{
\item \code{\link[multinet:Communities]{multinet::glouvain_ml()}}
\item \code{\link[multinet:Communities]{multinet::infomap_ml()}}
\item \code{\link[multinet:Communities]{multinet::clique_percolation_ml()}}
\item \code{\link[multinet:Communities]{multinet::abacus_ml()}}
}
\item \strong{Supra-graph (layer-collapsed) mode} (\code{supra_graph = TRUE}): collapses the
chosen layers into a single undirected graph (a \emph{supra-graph}), runs a
community method from \strong{\code{igraph}}, then maps community membership back to
each layer.
\itemize{
\item \code{method = "glouvain"} -> \code{\link[igraph:cluster_louvain]{igraph::cluster_louvain()}}
\item \code{method = "infomap"}  -> \code{\link[igraph:cluster_infomap]{igraph::cluster_infomap()}}
\item \code{method = "clique"}   -> clique-union components (based on
\code{\link[igraph:cliques]{igraph::cliques()}} + \code{\link[igraph:components]{igraph::components()}})
}
}

In both modes, the result is standardized to a \strong{tidy, edge-independent}
membership table (one row per \emph{actor–layer} membership) and optionally written
to disk.
}
\details{
\subsection{Output format (always the same)}{

The returned object is a data frame with columns:
\itemize{
\item \code{actor}: actor identifier (e.g., gene name)
\item \code{com}: community id (e.g., \code{"C1"}, \code{"C2"}, ... if relabeled; otherwise the
algorithm’s raw ids coerced to character)
\item \code{layer}: layer name
\item \code{method}: the method used (\code{"glouvain"}, \code{"infomap"}, \code{"clique"}, \code{"abacus"})
}

The object also carries attributes:
\itemize{
\item \code{community_sizes}: named integer vector = number of \strong{unique actors} per community
\item \code{layer_span}: named integer vector = number of \strong{unique layers} spanned by each community
\item \code{files}: list with file paths that were written (\code{rds}, \code{csv}, \code{summary_csv})
}
}

\subsection{Multilayer-native mode (\code{supra_graph = FALSE})}{

In this mode, \code{detectCom()} delegates community detection to the corresponding
\verb{multinet::*_ml()} function using your parameters (e.g., \code{gamma}, \code{omega} for
multilayer generalized Louvain).

\strong{Important practical note:} even in multilayer-native mode, \code{detectCom()}
may \strong{change} the final output compared to the raw \verb{multinet::*_ml()} result
because it can apply \strong{post-filtering} (\code{min.actors}, \code{min.layers}) and
\strong{optional relabeling} (\code{relabel_by_size}).

If you want the wrapper output to be as close as possible to the direct
multilayer algorithm output, use:
\itemize{
\item \code{min.actors = 1}, \code{min.layers = 1}, and
\item \code{relabel_by_size = FALSE}.
}
}

\subsection{Supra-graph mode (\code{supra_graph = TRUE})}{

In supra-graph mode, the function:
\enumerate{
\item Extracts intra-layer edges from the multilayer network.
\item Builds a single undirected graph where vertices are actors and edges are
aggregated across layers.
\item Runs an \code{igraph} community method on this collapsed graph.
\item Maps each actor’s community membership back to the layers in which the
actor appears.
}

Edge aggregation across layers is controlled by \code{edgeWeight}:
\itemize{
\item \code{"count"}: supra-edge weight = number of layers in which the edge appears
at least once.
\item \code{"sum"}: supra-edge weight = sum of per-layer edge weights across layers
(when available; otherwise edges default to weight 1).
}

\strong{Important:} supra-graph mode is a different analysis pipeline than
multilayer-native mode. You should not expect identical partitions between
these modes, even with similar settings.
}

\subsection{Filtering and relabeling (applies to all modes)}{

After community detection, communities are retained only if:
\itemize{
\item number of \strong{unique actors} in the community \verb{>= min.actors}, and
\item number of \strong{distinct layers} represented in the community \verb{>= min.layers}.
}

If \code{relabel_by_size = TRUE}, communities are renamed to \code{"C1"}, \code{"C2"}, ...
in decreasing order of community size (ties broken arbitrarily).
}
}
\examples{
# Build a tiny 2-layer multiplex from igraph graphs
g1 <- igraph::graph_from_data_frame(
  data.frame(from = c("a","b","c"), to = c("b","c","d"), w_ = c(1,1,1)),
  directed = FALSE
)
g2 <- igraph::graph_from_data_frame(
  data.frame(from = c("a","a","d"), to = c("c","d","e"), w_ = c(1,1,1)),
  directed = FALSE
)

net <- multinet::ml_empty()
multinet::add_igraph_layer_ml(net, g1, name = "E1")
multinet::add_igraph_layer_ml(net, g2, name = "E2")

# Multilayer-native GLouvain (supra_graph = FALSE)
comm_ml <- detectCom(
  net,
  method          = "glouvain",
  supra_graph     = FALSE,
  glouvain_gamma  = 1,
  glouvain_omega  = 1,
  min.actors      = 1,
  min.layers      = 1,
  relabel_by_size = FALSE,
  seed            = 1,
  save_to_rds     = FALSE,
  write_summary_csv = FALSE,
  verbose         = FALSE
)

# Supra-graph GLouvain (supra_graph = TRUE)
comm_supra <- detectCom(
  net,
  method          = "glouvain",
  supra_graph     = TRUE,
  edgeWeight      = "count",
  min.actors      = 1,
  min.layers      = 1,
  relabel_by_size = FALSE,
  seed            = 1,
  save_to_rds     = FALSE,
  write_summary_csv = FALSE,
  verbose         = FALSE
)

}
