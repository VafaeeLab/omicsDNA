% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/buildAdjacency.R
\name{buildAdjacency}
\alias{buildAdjacency}
\title{Build correlation‑filtered adjacency matrices by group}
\usage{
buildAdjacency(
  dataMatrix,
  sample_metadata,
  feature_ids,
  feature_metadata = NULL,
  group_col = "group",
  sample_col = "sample",
  feature_id_col = "feature_id",
  cor_method = c("spearman", "pearson"),
  pval_adjust = c("none", "fdr", "BH", "bonferroni"),
  pval_cutoff = 0.05,
  corr_threshold = 0.7,
  resample = TRUE,
  samples_per_group = 10,
  n_repeats = 50,
  verbose = TRUE,
  save_rds = TRUE,
  out_dir = file.path(getwd(), "omicsDNA_results"),
  file_prefix = "adjacency",
  compress = "xz",
  group_order = NULL
)
}
\arguments{
\item{dataMatrix}{Numeric matrix/data.frame; \strong{features in rows}, \strong{samples in columns}.}

\item{sample_metadata}{Data frame with at least \code{group_col} and \code{sample_col}.}

\item{feature_ids}{Character vector of feature IDs to include (should match \code{rownames(dataMatrix)});
missing features are zero‑padded in outputs so dimensions are consistent. IDs should be unique.}

\item{feature_metadata}{Optional feature annotations (currently not used; kept for API symmetry).}

\item{group_col}{Name of the grouping column in \code{sample_metadata}. Default \code{"group"}.}

\item{sample_col}{Name of the sample ID column in \code{sample_metadata}. Default \code{"sample"}.}

\item{feature_id_col}{Column name of IDs in \code{feature_metadata} (reserved; currently unused).}

\item{cor_method}{Correlation type: \code{"spearman"} or \code{"pearson"}. Default \code{"spearman"}.}

\item{pval_adjust}{Method for multiple testing correction of correlation p-values.
Options: "none" (default; use raw p-values), "fdr" (false discovery rate),
"BH" (Benjamini–Hochberg), or "bonferroni". \strong{Synonyms} "bh" and "bf" are accepted.
The cutoff in \code{pval_cutoff} will be applied to the adjusted values if this is not "none".}

\item{pval_cutoff}{P‑value cutoff for keeping an edge. Default \code{0.05}.}

\item{corr_threshold}{Absolute correlation threshold for keeping an edge. Default \code{0.7}.}

\item{resample}{Logical; enable balanced draws per group. Default \code{TRUE}.}

\item{samples_per_group}{Target samples drawn per group when resampling. Default \code{10}.}

\item{n_repeats}{Number of resampling repeats. Default \code{50}.}

\item{verbose}{Logical; print progress/messages. Default \code{TRUE}.}

\item{save_rds}{Logical; write result to an \code{.rds} file. Default \code{TRUE}.}

\item{out_dir}{Directory for saved files. Default \code{file.path(getwd(), "omicsDNA_results")}.}

\item{file_prefix}{Basename for saved files (no extension). Default \code{"adjacency"}.}

\item{compress}{Compression passed to \code{saveRDS()}: \code{TRUE/FALSE} or \code{"xz"}, \code{"gzip"}, \code{"bzip2"}.
Default \code{"xz"}.}

\item{group_order}{Optional character vector giving the desired order of groups/layers
in the returned list. Any groups not present in \code{sample_metadata[[group_col]]} are
ignored; any extra groups found in the metadata but not listed in \code{group_order}
will be appended after the specified order. Default \code{NULL} = keep the natural order.}
}
\value{
A list of adjacency matrices as described under \strong{Output shape}. The return
object carries \code{attr(x, "rds_file")} with the saved file path (or \code{NULL} if \code{save_rds = FALSE}).
}
\description{
The function is domain‑agnostic:
\itemize{
\item \emph{Omics:} features = genes/transcripts; samples = subjects/cells; groups = condition/age.
\item \emph{Social/behavioral:} features = variables; samples = respondents; groups = cohorts.
\item \emph{Sensors/engineering:} features = channels; samples = runs/windows; groups = modes.
}
}
\details{
Construct one or more feature‑by‑feature networks for each group of samples
by correlating feature profiles across samples in that group and keeping only
edges that satisfy \strong{both} an absolute correlation threshold and a p‑value
cutoff. Optionally, repeat the procedure with balanced draws per group to
produce multiple resampled networks (useful for consensus or stability work).

\strong{Input layout}
\itemize{
\item \code{dataMatrix} must be numeric with \strong{features in rows} and \strong{samples in columns}.
\item \code{sample_metadata} must contain a grouping column (\code{group_col}) and a sample ID column
(\code{sample_col}) whose values match \code{colnames(dataMatrix)}. Samples not found are ignored.
\item The analysis is restricted to \code{feature_ids} (order is preserved). Requested features
not present in \code{dataMatrix} are zero‑padded in the final adjacency so all outputs
share identical dimensions and ordering.
}

\strong{Computation per group}
\enumerate{
\item Assemble the group’s samples (optionally sub‑sampled if resampling is enabled).
\item (If available) run \code{WGCNA::goodSamplesGenes()} to drop problematic samples/features.
\item Compute correlations and p‑values with \code{WGCNA::corAndPvalue()} when \strong{WGCNA} is
installed; otherwise fall back to \code{Hmisc::rcorr()}. Diagonals are set to 0 (corr) and 1 (p).
\item Form the adjacency by zeroing entries that fail either filter:
\code{abs(corr) < corr_threshold} \strong{or} \code{p > pval_cutoff} (where \code{p} can be \strong{adjusted}
according to \code{pval_adjust}).
\item Expand to the full \verb{feature_ids × feature_ids} grid; missing features remain zero.
}

\strong{Resampling}
\itemize{
\item When \code{resample = TRUE}, each repeat draws up to \code{samples_per_group} samples
\strong{without replacement} within each group (\code{min(samples_per_group, n_in_group)}).
\item Groups with too few samples still contribute (using all available samples).
}

\strong{Size requirements & NA handling}
\itemize{
\item Requires \strong{≥ 3 samples} per group and \strong{≥ 2 features} after QC; otherwise a zero
matrix is returned for that group.
\item Non‑numeric columns are coerced to numeric; coercion may introduce \code{NA}s.
If \strong{WGCNA} is present, QC removes egregious rows/columns; otherwise the fallback
correlation uses pairwise information via \code{Hmisc::rcorr()}.
}

\strong{Output shape}
\itemize{
\item If \code{resample = FALSE}: a \strong{named list} of adjacency matrices (one per group).
\item If \code{resample = TRUE}: a \strong{list of length \code{n_repeats}}, where each element is a
named sub‑list of groups (\verb{out[[repeat]][[group]]}).
}

\strong{Persistence}
\itemize{
\item When \code{save_rds = TRUE}, the object is written to
\verb{<out_dir>/<file_prefix>_(list|boot)_YYYYMMDD-HHMMSS.rds} and also returned.
The absolute file path is attached as \code{attr(result, "rds_file")}.
}
}
\examples{
# Minimal toy example (no resampling)
set.seed(1)
X <- matrix(rnorm(5 * 6), nrow = 5,
            dimnames = list(paste0("g", 1:5), paste0("s", 1:6)))
meta <- data.frame(sample = colnames(X),
                   group  = rep(c("A","B"), each = 3))
adj <- buildAdjacency(
  dataMatrix        = X,
  sample_metadata   = meta,
  feature_ids       = rownames(X),
  group_col         = "group",
  sample_col        = "sample",
  resample          = FALSE,
  save_rds          = FALSE,
  verbose           = FALSE
)
lapply(adj, dim)  # one matrix per group

# Use adjusted p-values (BH) and explicit group order (B then A)
adj_bh <- buildAdjacency(
  dataMatrix        = X,
  sample_metadata   = meta,
  feature_ids       = rownames(X),
  group_col         = "group",
  sample_col        = "sample",
  pval_adjust       = "BH",            # also accepts "bh"
  pval_cutoff       = 0.1,
  resample          = FALSE,
  group_order       = c("B","A"),
  save_rds          = FALSE,
  verbose           = FALSE
)

}
\seealso{
\code{\link{edgesFromAdjacency}} to convert adjacency matrices to edge lists.
}
