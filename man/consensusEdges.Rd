% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/consensusEdges.R
\name{consensusEdges}
\alias{consensusEdges}
\title{Consensus edges across repetitions (works with tidy data, edge lists, or adjacencies)}
\usage{
consensusEdges(
  edges,
  prop_present = 0.7,
  min_reps = NULL,
  summary = c("mean", "median"),
  directed = FALSE,
  keep_self_loops = FALSE,
  na_rm = TRUE,
  as_list = TRUE,
  layer_col = NULL,
  rep_col = NULL,
  save_to_rds = TRUE,
  rds_file = NULL,
  write_csv = FALSE,
  csv_prefix = "consensus_edges",
  write_xlsx = FALSE,
  xlsx_file = NULL,
  results_dir = getOption("mlnet.results_dir", "omicsDNA_results"),
  verbose = TRUE
)
}
\arguments{
\item{edges}{A tidy \code{data.frame}, or a (nested) list of edge data frames, or a
(nested) list of adjacency matrices.}

\item{prop_present}{Numeric in (0, 1]; minimum fraction of repetitions (per
layer) that must contain an edge when \code{min_reps} is not supplied.
Threshold used is \code{ceiling(prop_present * n_repeats)}. Default \code{0.7}.}

\item{min_reps}{Optional positive integer; minimum number of repetitions
(per layer) required for an edge to be kept. If provided, it overrides
\code{prop_present}.}

\item{summary}{\code{"mean"}, \code{"median"}, or a function that takes a numeric vector
and returns a single number. This summary is applied \strong{across repetitions}.
Default \code{c("mean","median")} (matched to \code{"mean"} unless a function is passed).}

\item{directed}{Logical; if \code{FALSE} (default) treat graphs as undirected by
sorting endpoints before counting and summarising edges. If \code{TRUE}, treat as directed.}

\item{keep_self_loops}{Logical; keep \code{from == to} edges (\code{TRUE}) or drop them
(\code{FALSE}, default).}

\item{na_rm}{Logical; drop \code{NA} values when computing the \strong{across‑rep} weight
summary. Default \code{TRUE}. (Note: duplicates within a repetition are always
averaged by mean with \code{na.rm = TRUE}.)}

\item{as_list}{Logical; return a named list (one data frame per layer). If
\code{FALSE}, return a single tidy data frame with a \code{layer} column. Default \code{TRUE}.}

\item{layer_col, rep_col}{For \code{data.frame} input only: column names holding the
layer and repetition identifiers. If \code{NULL}, the function tries to auto‑detect
them as described above.}

\item{save_to_rds}{Logical; save the result as an RDS file. Default \code{TRUE}.}

\item{rds_file}{Optional filename for the RDS. If relative, it is saved under
\code{results_dir}; if absolute, it is used as given. Default \code{NULL} (auto‑named).}

\item{write_csv}{Logical; write CSV output(s). If \code{as_list = TRUE}, one file per
layer is written. Default \code{FALSE}.}

\item{csv_prefix}{Basename prefix for CSV files. Default \code{"consensus_edges"}.}

\item{write_xlsx}{Logical; write an XLSX file (requires \strong{writexl}). If
\code{as_list = TRUE}, a multi‑sheet workbook is produced (one sheet per layer);
otherwise a single‑sheet workbook is written. Default \code{FALSE}.}

\item{xlsx_file}{Optional XLSX filename; if relative, saved under \code{results_dir}.
Default \code{NULL} (auto‑named).}

\item{results_dir}{Output directory. Default
\code{getOption("mlnet.results_dir", "omicsDNA_results")}.}

\item{verbose}{Logical; print progress per layer and file save messages.
Default \code{TRUE}.}
}
\value{
If \code{as_list = TRUE}, a named list of data frames (one per layer), each
with columns \code{from}, \code{to}, \code{weight}, \code{n_present}, \code{n_repeats}, \code{prop_present}.
If \code{as_list = FALSE}, a single tidy data frame with an additional \code{layer} column.
}
\description{
\strong{Inputs accepted}
\itemize{
\item A tidy \code{data.frame} with columns \code{from}, \code{to}, \code{weight}, plus layer and
(optionally) repetition identifiers; or
\item A (possibly nested) \code{list} of edge data frames; or
\item A (possibly nested) \code{list} of adjacency matrices (base or sparse). Adjacencies
are first converted with \code{edgesFromAdjacency()} (which must be available).
}

\strong{How it works (per layer)}
\enumerate{
\item Normalise the input into a tidy table with columns \code{layer}, \code{rep}, \code{from},
\code{to}, \code{weight}. For nested lists, the \strong{last} list level is treated as
\code{layer}; all higher levels are collapsed into a single \code{rep} label joined
by \code{"|"}.
\item If \code{directed = FALSE} (default), canonicalise endpoints so \verb{A–B == B–A}.
If \code{keep_self_loops = FALSE} (default), drop \code{from == to}.
\item Within each \verb{(layer, rep, from, to)} combination, average duplicate rows by
\strong{mean} (\code{na.rm = TRUE}) to obtain one weight per repetition.
\item Count, for each edge \verb{(from, to)}, in how many repetitions it appears.
Keep the edge if it meets the presence criterion: at least \code{min_reps}
repetitions (if provided), otherwise at least
\code{ceiling(prop_present * n_repeats)} (with a minimum of 1).
\item For the kept edges, summarise their weights \strong{across repetitions} using
either \code{"mean"}, \code{"median"}, or a user‑supplied function; \code{na_rm} controls
how missing weights are handled in this summary step.
}

\strong{Layer/rep auto‑detection (data.frame input)}
\itemize{
\item The layer column is required and auto‑detected from one of
\code{layer}, \code{Layer}, \code{group}, \code{Group}. If none is found, set \code{layer_col}.
\item The repetition column is optional and auto‑detected from one of
\code{rep}, \code{repeat}, \code{repetition}, \code{bootstrap}, \code{iter}, \code{iteration}, \code{Rep}, \code{Repeat}.
If none is found, repetitions are assumed to be \code{"1"}.
}

\strong{Notes on adjacency inputs}
\itemize{
\item Conversion relies on \code{edgesFromAdjacency()}. For sparse matrices, only
stored (non‑zero) entries are enumerated. Zeros are not stored in sparse
formats and cannot be recovered by setting \code{drop_zeros = FALSE}.
}

\strong{Output}
\itemize{
\item If \code{as_list = TRUE}: a named list (one data frame per layer), each with
columns \code{from}, \code{to}, \code{weight} (summarised across repetitions),
\code{n_present}, \code{n_repeats}, and \code{prop_present}.
\item If \code{as_list = FALSE}: a single tidy data frame with the same columns plus
a \code{layer} column.
}

\strong{Persistence}
\itemize{
\item When \code{save_to_rds = TRUE}, results are written under \code{results_dir}. Filenames
are auto‑generated by type: \verb{consensus_list_<timestamp>.rds} for lists or
\verb{consensus_df_<timestamp>.rds} for a single data frame. If \code{rds_file} is
given, a relative path is placed under \code{results_dir} and an absolute path
is respected. Optional per‑layer CSVs (\code{write_csv = TRUE}) and a single
XLSX export (\code{write_xlsx = TRUE}, requires \strong{writexl}) are supported.
}
}
\details{
Identify edges that reproducibly occur across repeated networks within each
layer (e.g., age group, condition), then summarise their weights across
repetitions. The procedure is domain‑agnostic and applies equally to
co‑expression graphs, interaction networks, or infrastructure graphs.
}
\examples{
\dontrun{
## Example 1: tidy edges with explicit layer/rep columns
df <- data.frame(
  layer  = rep(c("A","A","B","B"), each = 3),
  rep    = rep(c("r1","r2"), times = 6),
  from   = c("g1","g2","g1","g1","g2","g2","g1","g3","g1","g2","g3","g1"),
  to     = c("g2","g3","g3","g2","g3","g1","g3","g2","g2","g1","g1","g3"),
  weight = rnorm(12)
)
cons_A_list <- consensusEdges(df, prop_present = 0.7, summary = "median", as_list = TRUE)

## Example 2: nested list of adjacency matrices (repeat -> layer)
## (requires edgesFromAdjacency)
adj_list <- list(
  `1` = list(A = diag(0, 3), B = diag(0, 3)),
  `2` = list(A = diag(0, 3), B = diag(0, 3))
)
cons_df <- consensusEdges(adj_list, prop_present = 0.5, summary = "mean", as_list = FALSE)
}

}
\seealso{
\code{\link{edgesFromAdjacency}} for converting adjacency matrices to edge tables.
}
