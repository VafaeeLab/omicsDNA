% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/gsea_msigdbr_layer_pairs.R
\name{gsea_msigdbr_layer_pairs}
\alias{gsea_msigdbr_layer_pairs}
\title{Pairwise preranked GSEA across consecutive layers with MSigDB (fgsea + msigdbr)}
\usage{
gsea_msigdbr_layer_pairs(
  net,
  layer_order = NULL,
  scores_by_layer = NULL,
  cor_attr = c("cor", "r", "rho", "correlation"),
  padj_attr = c("padj", "fdr", "q", "adj_p", "p_adj", "p.adj", "p_fdr"),
  pair_rank_by = c("delta_signed_log10_padj", "delta_cor", "signed_log10_padj_L1",
    "signed_log10_padj_L2", "cor_L1", "cor_L2"),
  missing_policy = c("impute", "drop"),
  impute_cor = 0,
  impute_padj = 1,
  case_insensitive = TRUE,
  communities = NULL,
  enrich_scope = c("layer", "community"),
  restrict_genes = NULL,
  msigdb_species = "Homo sapiens",
  msigdb_collections = c("H", "C2", "C5"),
  msigdb_subcategories = NULL,
  minSize = 15,
  maxSize = 500,
  nperm = NULL,
  results_dir = getOption("mlnet.results_dir", "omicsDNA_results"),
  run_name = "gsea_layerpairs",
  top_n = 10,
  format = c("png", "pdf", "jpg"),
  width = 9,
  height = 7,
  dpi = 300,
  show_in_rstudio = TRUE,
  dotplot_width = width,
  dotplot_height = height,
  enrich_width = width,
  enrich_height = height,
  dotplot_margin_cm = c(0.5, 0.5, 0.5, 0.5),
  enrich_margin_cm = c(0.5, 0.5, 0.5, 0.5),
  cnet_show = TRUE,
  cnet_top_terms = 10,
  cnet_use = c("leadingEdge", "members"),
  cnet_layout = "fr",
  cnet_width = width,
  cnet_height = height,
  cnet_margin_cm = c(0.5, 0.5, 0.5, 0.5),
  cnet_term_label_size = 3.2,
  cnet_gene_label_size = 2.4,
  cnet_gene_label_color = "grey25",
  ton_show = TRUE,
  ton_top_terms = 10,
  ton_min_overlap = 1,
  ton_layout = "fr",
  ton_width = width,
  ton_height = height,
  ton_margin_cm = c(0.5, 0.5, 0.5, 0.5),
  seed = NULL,
  verbose = TRUE
)
}
\arguments{
\item{net}{A \pkg{multinet} object containing multiple layers. Each layer is expected to be
convertible to an \pkg{igraph} graph where vertex \code{name} encodes gene identifiers.
Layer names are obtained via \code{multinet::layers_ml(net)}.}

\item{layer_order}{Optional character vector specifying the order in which layers are traversed.
Consecutive pairs are formed from this order. If \code{NULL}, the ordering provided by
\code{multinet::layers_ml(net)} is used.}

\item{scores_by_layer}{Optional named list \code{layer -> data.frame(gene, cor, padj)} providing
per-layer statistics explicitly. When supplied for a layer, these values override vertex
attributes for that layer.}

\item{cor_attr, padj_attr}{Character vectors of candidate vertex-attribute names used to locate the
correlation/effect-size and adjusted p-value attributes for each layer. The first match
(case-insensitive) is used.}

\item{pair_rank_by}{Ranking recipe used to construct the per-gene score for comparing \code{L1}
and \code{L2}. See function body for supported options and their definitions.}

\item{missing_policy}{Strategy for handling missing values across layer pairs: \code{"impute"} or
\code{"drop"}.}

\item{impute_cor, impute_padj}{Values used when \code{missing_policy = "impute"}.}

\item{case_insensitive}{If \code{TRUE} (default), gene symbols are upper-cased for matching.}

\item{communities}{Optional data frame describing community membership; required when
\code{enrich_scope = "community"}. Must contain \code{actor} (gene), \code{layer}, and a
community identifier column (\code{cid}, \code{com}, or \code{community}).}

\item{enrich_scope}{Either \code{"layer"} or \code{"community"}.}

\item{restrict_genes}{Optional character vector defining a restricted gene list. If provided,
the ranked gene list used for each enrichment run (per layer pair, and per \code{cid} in
community scope) is intersected with this vector. Only remaining genes contribute to ranking and
to pathway sizes; pathways outside \code{minSize}–\code{maxSize} after restriction are excluded,
and runs with fewer than \code{minSize} ranked genes are skipped.}

\item{msigdb_species}{Species name passed to \pkg{msigdbr} (e.g., \code{"Homo sapiens"}).}

\item{msigdb_collections}{MSigDB collections/categories to include (e.g., \code{c("H","C2","C5")}).}

\item{msigdb_subcategories}{Optional MSigDB subcategories/subcollections filter.}

\item{minSize, maxSize}{Pathway size bounds after intersecting with ranked genes.}

\item{nperm}{If \code{NULL}, uses \code{fgseaMultilevel()} (recommended). If an integer, uses
\code{fgsea()} with \code{nperm}.}

\item{results_dir}{Base output directory.}

\item{run_name}{Prefix for the run folder name (timestamp appended).}

\item{top_n}{Number of top positively/negatively enriched pathways shown in the dot plot.}

\item{format}{Plot format: \code{"png"}, \code{"pdf"}, or \code{"jpg"}.}

\item{width, height, dpi}{Default plot geometry (inches; DPI ignored for PDF).}

\item{show_in_rstudio}{If \code{TRUE}, plots are also printed to the current device.}

\item{dotplot_width, dotplot_height, enrich_width, enrich_height}{Plot-specific sizes (inches).}

\item{dotplot_margin_cm, enrich_margin_cm}{Margins \code{c(top,right,bottom,left)} in cm.}

\item{cnet_show}{If \code{TRUE}, attempts to draw a term–gene concept network (requires \pkg{ggraph}).}

\item{cnet_top_terms}{Number of top terms (by adjusted p-value) included in the concept network.}

\item{cnet_use}{Use \code{"leadingEdge"} (default) or \code{"members"} for term–gene edges.}

\item{cnet_layout}{Layout name passed to \pkg{ggraph}.}

\item{cnet_width, cnet_height}{Concept network plot size (inches).}

\item{cnet_margin_cm}{Concept network margins in cm.}

\item{cnet_term_label_size, cnet_gene_label_size}{Text sizes for labels.}

\item{cnet_gene_label_color}{Colour for gene labels.}

\item{ton_show}{If \code{TRUE}, attempts to draw a term-only overlap network (requires \pkg{ggraph}).}

\item{ton_top_terms}{Number of top terms included in term-only network.}

\item{ton_min_overlap}{Minimum shared genes to draw a term–term edge.}

\item{ton_layout}{Layout for term-only network.}

\item{ton_width, ton_height}{Term-only plot size (inches).}

\item{ton_margin_cm}{Term-only margins in cm.}

\item{seed}{Optional integer seed for reproducibility.}

\item{verbose}{If \code{TRUE}, print progress messages.}
}
\value{
Invisibly returns a list with:
\describe{
\item{\code{run_dir}}{Path to the timestamped run folder containing all outputs.}
\item{\code{by_pair}}{Named list keyed by \code{"<L1>_vs_<L2>"} with file paths for each pair.
In community scope, each pair entry is a list keyed by \code{"cid_<cid>"} for communities that
produced results.}
\item{\code{summary_file}}{Path to \code{SUMMARY.csv} (run manifest).}
}
}
\description{
This function performs \strong{preranked gene set enrichment analysis (GSEA)} for each
\strong{consecutive (adjacent) pair of layers} in a multilayer network (e.g.,
\code{E1 -> E2 -> M1 -> M2}). For every adjacent layer pair \code{(L1, L2)}, the function:
\enumerate{
\item extracts per-gene statistics for each layer (typically an effect size such as a
correlation-like value, and an adjusted p-value);
\item builds a \strong{single ranked gene vector} describing how genes differ between
\code{L1} and \code{L2} (controlled by \code{pair_rank_by});
\item tests enrichment of \strong{MSigDB} gene sets (retrieved via \pkg{msigdbr})
using \pkg{fgsea};
\item saves results tables and publication-ready plots for each layer pair
(and optionally for each community within that pair).
}

Two enrichment scopes are supported:
\itemize{
\item \code{enrich_scope = "layer"}: one GSEA run per layer pair using the full ranked universe.
\item \code{enrich_scope = "community"}: one GSEA run per community identifier (\code{cid}) per
layer pair, where the ranked universe is restricted to genes belonging to that community
(and optionally further restricted by \code{restrict_genes}).
}
}
\details{
Pairwise preranked GSEA (MSigDB) across consecutive multilayer network layers

\section{Conceptual inputs}{
The method requires, for each layer, gene-level statistics consisting of:
\itemize{
\item a signed effect size (e.g., correlation, Spearman rho, or another association measure);
\item an adjusted p-value (e.g., FDR / q-value).
}
These statistics can be obtained in either of two ways:
\enumerate{
\item \strong{From \code{net}:} each layer is converted to an \pkg{igraph} object, where vertex
\code{name} represents the gene identifier. Correlation and adjusted p-values are read
from vertex attributes using candidate names in \code{cor_attr} and \code{padj_attr}.
\item \strong{From \code{scores_by_layer}:} a user-supplied named list
\code{layer -> data.frame(gene, cor, padj)} that overrides vertex attributes for the
specified layers.
}
The function then constructs a ranked gene list for each consecutive layer pair and applies GSEA
to MSigDB pathways.
}

\section{Ranking and directionality}{
GSEA is run on a named numeric vector (the ranked list), where larger values correspond to
higher-ranked genes. Results are labelled as:
\itemize{
\item \code{direction = "L1_up"} when \code{NES >= 0};
\item \code{direction = "L2_up"} when \code{NES < 0}.
}
Interpretation depends on \code{pair_rank_by}, but generally:
\itemize{
\item \code{NES > 0} indicates pathway genes tend to occur near the top of the ranking (more
consistent with the \code{L1}-side of the chosen contrast);
\item \code{NES < 0} indicates pathway genes tend to occur near the bottom of the ranking (more
consistent with the \code{L2}-side of the chosen contrast).
}
}

\section{Gene matching and missing values}{
Gene identifiers are matched to MSigDB gene symbols. If \code{case_insensitive = TRUE} (default),
gene symbols are upper-cased prior to matching to improve robustness across inputs.

When statistics are missing for a gene in one of the two layers, behaviour is controlled by
\code{missing_policy}:
\itemize{
\item \code{"impute"} (default): missing correlations and p-values are replaced by
\code{impute_cor} and \code{impute_padj};
\item \code{"drop"}: genes with any missing statistic across the pair are removed.
}
}

\section{Restriction of the ranked universe (\code{restrict_genes})}{
\code{restrict_genes} optionally restricts the ranked gene list used for GSEA. When provided, the
ranked vector for each analysis unit is filtered to genes present in \code{restrict_genes}:
\itemize{
\item in layer scope: \code{(ranked genes for the pair) ∩ restrict_genes};
  \item in community scope: \code{(community genes for the pair) ∩ restrict_genes}.
}
Pathways are then intersected with the remaining ranked genes, and only pathways whose effective
size lies within \code{minSize}–\code{maxSize} are tested. If fewer than \code{minSize} ranked
genes remain after restriction, that analysis unit is skipped.
}

\section{Outputs written to disk}{
A timestamped run directory is created at:
\code{file.path(results_dir, paste0(run_name, "_", <timestamp>))}.

Each layer pair has its own subdirectory: \code{"<L1>_vs_<L2>"}.
In community scope, results are further nested in \code{"cid_<cid>"} subfolders (created only when
outputs are produced).

For each analysis unit (pair, or pair + community), the function writes:
\itemize{
\item \strong{Results table (CSV):} \code{gsea_pair_<L1>_vs_<L2>[ _cid<cid> ].csv}
\item \strong{Dot plot:} \code{gsea_pair_dot_<L1>_vs_<L2>[ _cid<cid> ].<format>}
\item \strong{Enrichment plots:}
\code{gsea_pair_enrich_topL1_<L1>_vs_<L2>[ _cid<cid> ].<format>} and
\code{gsea_pair_enrich_topL2_<L1>_vs_<L2>[ _cid<cid> ].<format>}
\item \strong{Concept network (optional):} \code{gsea_pair_cnet_<L1>_vs_<L2>[ _cid<cid> ].<format>}
\item \strong{Term overlap network (optional):} \code{gsea_pair_termnet_<L1>_vs_<L2>[ _cid<cid> ].<format>}
}
A run-level manifest \code{SUMMARY.csv} is written to the run directory and records file paths and
basic counts for each analysis unit.
}

\section{Robust graph construction when overlaps are absent}{
For term-only overlap networks (and occasionally for concept networks), it is plausible that no
term–term or term–gene edges remain after filtering. The function therefore constructs valid empty
edge tables when necessary so that plots render as isolated nodes rather than failing during graph
construction.
}
}
