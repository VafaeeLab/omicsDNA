% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/gsea_msigdbr_layer_pairs.R
\name{gsea_msigdbr_layer_pairs}
\alias{gsea_msigdbr_layer_pairs}
\title{Pairwise GSEA (MSigDB) across consecutive multilayer network layers
with dot, enrichment, cNET (terms+genes), and term‑only overlap plots}
\usage{
gsea_msigdbr_layer_pairs(
  net,
  layer_order = NULL,
  scores_by_layer = NULL,
  cor_attr = c("cor", "r", "rho", "correlation"),
  padj_attr = c("padj", "fdr", "q", "adj_p", "p_adj", "p.adj", "p_fdr"),
  pair_rank_by = c("delta_signed_log10_padj", "delta_cor", "signed_log10_padj_L1",
    "signed_log10_padj_L2", "cor_L1", "cor_L2"),
  missing_policy = c("impute", "drop"),
  impute_cor = 0,
  impute_padj = 1,
  case_insensitive = TRUE,
  communities = NULL,
  enrich_scope = c("layer", "community"),
  restrict_genes = NULL,
  msigdb_species = "Homo sapiens",
  msigdb_collections = c("H", "C2", "C5"),
  msigdb_subcategories = NULL,
  minSize = 15,
  maxSize = 500,
  nperm = NULL,
  results_dir = getOption("mlnet.results_dir", "omicsDNA_results"),
  run_name = "gsea_layerpairs",
  top_n = 10,
  format = c("png", "pdf", "jpg"),
  width = 9,
  height = 7,
  dpi = 300,
  show_in_rstudio = TRUE,
  dotplot_width = width,
  dotplot_height = height,
  enrich_width = width,
  enrich_height = height,
  dotplot_margin_cm = c(0.5, 0.5, 0.5, 0.5),
  enrich_margin_cm = c(0.5, 0.5, 0.5, 0.5),
  cnet_show = TRUE,
  cnet_top_terms = 10,
  cnet_use = c("leadingEdge", "members"),
  cnet_layout = "fr",
  cnet_width = width,
  cnet_height = height,
  cnet_margin_cm = c(0.5, 0.5, 0.5, 0.5),
  cnet_term_label_size = 3.2,
  cnet_gene_label_size = 2.4,
  cnet_gene_label_color = "grey25",
  ton_show = TRUE,
  ton_top_terms = 10,
  ton_min_overlap = 1,
  ton_layout = "fr",
  ton_width = width,
  ton_height = height,
  ton_margin_cm = c(0.5, 0.5, 0.5, 0.5),
  seed = NULL,
  verbose = TRUE
)
}
\arguments{
\item{net}{A \pkg{multinet} object. Layers come from
\code{multinet::layers_ml(net)} and are coerced to \pkg{igraph}s via
\code{as.list(net)}. Vertex attributes provide \code{cor}/\code{padj}
unless overridden by \code{scores_by_layer}.}

\item{layer_order}{Character vector giving the traversal order of layers.
Pairs are formed as \code{(L1,L2)}, \code{(L2,L3)}, ... in this order.
Default: \code{multinet::layers_ml(net)}.}

\item{scores_by_layer}{Optional named list \code{layer ->
  data.frame(gene, cor, padj)} that overrides vertex attributes for the
specified layers.}

\item{cor_attr, padj_attr}{Character vectors of candidate vertex attribute
names for correlation and adjusted p‑value. The first present in a layer
is used (case‑insensitive).}

\item{pair_rank_by}{Ranking recipe. One of:
\code{"delta_signed_log10_padj"} (default), \code{"delta_cor"},
\code{"signed_log10_padj_L1"}, \code{"signed_log10_padj_L2"},
\code{"cor_L1"}, \code{"cor_L2"}. See Details for formulas.}

\item{missing_policy}{\code{"impute"} (default; uses \code{impute_cor=0},
\code{impute_padj=1}) or \code{"drop"} to remove genes with missing
values.}

\item{impute_cor, impute_padj}{Numeric values used under
\code{missing_policy="impute"}.}

\item{case_insensitive}{Logical; if \code{TRUE} (default) gene symbols are
upper‑cased for matching.}

\item{communities}{Optional data.frame describing communities; required when
\code{enrich_scope = "community"}. Must contain \code{actor}, \code{layer}
and one of \code{cid}, \code{com}, \code{community}.}

\item{enrich_scope}{Either \code{"layer"} (default; one GSEA per
layer‑pair) or \code{"community"} (one GSEA per community ID per
layer‑pair).}

\item{restrict_genes}{Optional character vector of genes. When provided, the
ranked universe is restricted to \code{intersect(all_genes,
  restrict_genes)}; in community scope, each community is further restricted
to its gene set.}

\item{msigdb_species}{Species string for \pkg{msigdbr} (e.g.,
\code{"Homo sapiens"}).}

\item{msigdb_collections}{Character vector of MSigDB collections (e.g.,
\code{c("H","C2","C5")}).}

\item{msigdb_subcategories}{Optional vector of subcategories (e.g.,
\code{c("CP:KEGG","GO:BP")}).}

\item{minSize, maxSize}{Integer bounds for pathway sizes after intersecting
with the ranked universe.}

\item{nperm}{If \code{NULL} (default), uses \code{fgseaMultilevel()}
(recommended). If a positive integer, uses \code{fgsea()} with
\code{nperm} permutations.}

\item{results_dir}{Base output directory (created if needed).}

\item{run_name}{Prefix for the run folder (a timestamp
\code{"_YYYY-mm-dd_HHMMSS"} is appended).}

\item{top_n}{Number of top up/down pathways by adjusted p‑value to show in
the dot plot.}

\item{format}{Image format for plots: \code{"png"}, \code{"pdf"} or
\code{"jpg"} (DPI ignored for PDF).}

\item{width, height, dpi}{Default plot geometry (inches) and DPI (when
per‑plot sizes not given).}

\item{show_in_rstudio}{If \code{TRUE}, also prints plots to the current
device.}

\item{dotplot_width, dotplot_height, enrich_width, enrich_height}{Per‑plot
sizes (inches) for dot and enrichment plots. Defaults fall back to
\code{width}/\code{height}.}

\item{dotplot_margin_cm, enrich_margin_cm}{Numeric vectors
\code{c(top,right,bottom,left)} in \strong{cm} specifying plot margins.}

\item{cnet_show}{If \code{TRUE} (default), build the cNET plot.}

\item{cnet_top_terms}{Number of top terms (by \code{padj}) to include in
cNET.}

\item{cnet_use}{\code{"leadingEdge"} (default; connect terms to FGSEA
leading‑edge genes) or \code{"members"} (connect all member genes present
in the ranked universe).}

\item{cnet_layout}{Layout name passed to \pkg{ggraph} (e.g., \code{"fr"},
\code{"kk"}, \code{"lgl"}).}

\item{cnet_width, cnet_height}{Size (inches) for the cNET plot.}

\item{cnet_margin_cm}{Numeric vector \code{c(top,right,bottom,left)} in
\strong{cm} for cNET margins.}

\item{cnet_term_label_size, cnet_gene_label_size}{Numeric text sizes for term
and gene labels in cNET.}

\item{cnet_gene_label_color}{Color for gene labels in cNET (default
\code{"grey25"}).}

\item{ton_show}{If \code{TRUE} (default), build the term‑only overlap
network.}

\item{ton_top_terms}{Number of top terms (by \code{padj}) to include in the
term‑only network.}

\item{ton_min_overlap}{Minimum number of shared genes to draw a term–term
edge.}

\item{ton_layout}{Layout for the term‑only network: \code{"fr"},
\code{"kk"}, \code{"lgl"}, or \code{"mds"}.}

\item{ton_width, ton_height}{Size (inches) for the term‑only plot.}

\item{ton_margin_cm}{Numeric vector \code{c(top,right,bottom,left)} in
\strong{cm} for term‑only margins.}

\item{seed}{Optional integer seed for RNG/reproducible layouts.}

\item{verbose}{If \code{TRUE} (default), print progress messages.}
}
\value{
A list (returned invisibly) with:
\describe{
\item{\code{run_dir}}{Path to the timestamped run folder.}
\item{\code{by_pair}}{Named list. For \code{enrich_scope = "layer"},
each \code{by_pair[[pair]]} is a list of file paths:
\code{csv_file}, \code{dotplot_file}, \code{enrich_L1_file},
\code{enrich_L2_file}, \code{cnet_file}, \code{termnet_file}.
For \code{enrich_scope = "community"}, each
\code{by_pair[[pair]][["cid_<CID>"]]} is such a list for that
community.}
\item{\code{summary_file}}{Path to the manifest \code{SUMMARY.csv}.}
}
}
\description{
For each \strong{consecutive pair} of layers in \code{layer_order} (e.g.,
\code{E1 -> E2 -> M1 -> M2}), this function builds a \strong{per‑gene ranking}
from layer‑specific correlation and adjusted p‑value, runs preranked GSEA
via \pkg{fgsea}, and writes five outputs per pair:
\itemize{
\item a tidy CSV of enriched pathways (ES, NES, pval, padj, size,
leadingEdge, etc.);
\item a \strong{dot} (bubble) summary of top up/down pathways by adjusted
p‑value;
\item classic \strong{running‑sum enrichment} plots for the best L1‑up and
best L2‑up pathways;
\item a \strong{cNET (term–gene) concept network} where \strong{both term names
and gene symbols are labelled} (terms are color‑coded by
\eqn{-\log_{10}(adj\;p)} and sized by member count; genes are grey);
\item a \strong{term‑only overlap network} (nodes = terms, edges reflect shared
genes; numbers at nodes are the pathway gene counts used; color
encodes \eqn{-\log_{10}(adj\;p)}).
}

Two scopes are supported:
\itemize{
\item \code{enrich_scope = "layer"} (default): one GSEA per layer‑pair
(full ranked universe).
\item \code{enrich_scope = "community"}: one GSEA per community ID
(\code{cid}) per layer‑pair, using a \code{communities} table
(\code{actor}, \code{layer}, \code{cid}). In this mode, the ranking
for each GSEA is restricted to genes in that community (and
optionally also to \code{restrict_genes}).
}

Additionally, a \strong{restriction gene set} (\code{restrict_genes}) can be
supplied. In all modes, the GSEA ranking is restricted to:
\preformatted{
  intersect(all_ranked_genes, restrict_genes)
}
and, in community scope, further intersected with the community’s gene set.
}
\details{
Pairwise GSEA (MSigDB) between consecutive network layers

\strong{Workflow.}
\enumerate{
\item Layers are taken from \code{multinet::layers_ml(net)} (or from
\code{layer_order} if supplied); consecutive pairs
\code{(L1, L2)} are formed in that order.
\item Per layer, per‑gene statistics come either from vertex attributes
(first match among \code{cor_attr}, \code{padj_attr}) or from
\code{scores_by_layer[[layer]]}.
\item A \strong{pairwise ranking} \eqn{r_g} (for gene \eqn{g}) is computed
using \code{pair_rank_by}:
\describe{
\item{\code{"delta_signed_log10_padj"} (default)}{
\eqn{\mathrm{sign}(cor_{L1}) \cdot -\log_{10}(padj_{L1}) -
                 \mathrm{sign}(cor_{L2}) \cdot -\log_{10}(padj_{L2})}
}
\item{\code{"delta_cor"}}{\eqn{cor_{L1} - cor_{L2}}}
\item{\code{"signed_log10_padj_L1"}}{
\eqn{\mathrm{sign}(cor_{L1}) \cdot -\log_{10}(padj_{L1})}}
\item{\code{"signed_log10_padj_L2"}}{
\eqn{\mathrm{sign}(cor_{L2}) \cdot -\log_{10}(padj_{L2})}}
\item{\code{"cor_L1"}}{\eqn{cor_{L1}}}
\item{\code{"cor_L2"}}{\eqn{cor_{L2}}}
}
\item MSigDB pathways (via \pkg{msigdbr}) are intersected with the ranked
universe, size‑filtered by \code{minSize}/\code{maxSize}, and
enriched using:
\itemize{
\item \strong{\code{fgseaMultilevel()}} when \code{nperm = NULL}
(recommended);
\item classic \strong{\code{fgsea()}} when \code{nperm} is a
positive integer.
}
\item In \strong{community scope}, for each pair \code{(L1,L2)} and
community ID \code{cid}, the ranking is restricted to genes in that
community (and optionally to \code{restrict_genes}).
\item Plots/CSVs are saved into a timestamped run folder; when
\code{show_in_rstudio = TRUE} they are also printed to the active
device.
}

\strong{MSigDB compatibility.} Around msigdbr v10 the API shifted from
“category” to “collection\link{/subcategory}”. This function accepts
\code{msigdb_collections} and optional \code{msigdb_subcategories}, and
internally adapts to both styles. If a requested subcategory is not
available for a collection, a short note is emitted and processing continues.

\strong{Communities (community scope).}
\itemize{
\item \code{communities} must be a data.frame.
\item It must contain an \emph{actor} column (gene symbol / actor ID),
a \emph{layer} column, and a community ID column.
\item The community column is normalised to \code{cid} using the first
available name among \code{cid}, \code{com}, or \code{community}.
\item Actors are normalised via \code{case_insensitive}; in practice,
gene symbols are upper‑cased when \code{case_insensitive = TRUE}.
}

\strong{cNET (term–gene).} Term nodes are colored by
\eqn{-\log_{10}(adj\;p)} and sized by the number of connected genes
(leading edge or full members per \code{cnet_use}). \emph{Gene symbols are
always labelled} (smaller, grey) alongside term labels (larger). Positions
are computed via \pkg{ggraph} and labels use \pkg{ggrepel} when available.

\strong{Term‑only overlap.} Nodes are the selected top terms (by
\code{padj}); edges connect terms sharing at least
\code{ton_min_overlap} genes. Numbers near nodes give the gene counts used.

\strong{Output structure.}
For a pair \code{L1_vs_L2}, layer scope:
\preformatted{
  <results_dir>/<run_name>_<YYYY-mm-dd_HHMMSS>/<L1_vs_L2>/
    gsea_pair_<L1_vs_L2>.csv
    gsea_pair_dot_<L1_vs_L2>.<format>
    gsea_pair_enrich_topL1_<L1_vs_L2>.<format>
    gsea_pair_enrich_topL2_<L1_vs_L2>.<format>
    gsea_pair_cnet_<L1_vs_L2>.<format>
    gsea_pair_termnet_<L1_vs_L2>.<format>
}

Community scope adds a subfolder per community ID:
\preformatted{
  <results_dir>/<run_name>_<YYYY-mm-dd_HHMMSS>/<L1_vs_L2>/cid_<CID>/
    gsea_pair_<L1_vs_L2>_cid<CID>.csv
    gsea_pair_dot_<L1_vs_L2>_cid<CID>.<format>
    gsea_pair_enrich_topL1_<L1_vs_L2>_cid<CID>.<format>
    gsea_pair_enrich_topL2_<L1_vs_L2>_cid<CID>.<format>
    gsea_pair_cnet_<L1_vs_L2>_cid<CID>.<format>
    gsea_pair_termnet_<L1_vs_L2>_cid<CID>.<format>
}

Plus a run‑level manifest:
\preformatted{
  <results_dir>/<run_name>_<YYYY-mm-dd_HHMMSS>/SUMMARY.csv
}
}
\section{Units, scaling and labels}{

\itemize{
\item All \code{*_margin_cm} arguments are in \strong{centimetres} and applied
as plot margins.
\item Network node sizes are rescaled to a sensible visual range
(terms > genes).
\item cNET always prints both term names and gene symbols (genes smaller,
grey).
}
}

\examples{
\dontrun{
## Example objects:
##   - net  : your multilayer network (multinet::ml.network)
##   - comm : communities with columns actor / layer / cid (or com/community)
##   - oxidative_stress_genes : custom gene set, e.g. pc_genes[1:100]

## 1) Layer-pair GSEA on all genes ----------------------------------------
gsea_layer_pairs <- gsea_msigdbr_layer_pairs(
  net                  = net,
  layer_order          = multinet::layers_ml(net),
  enrich_scope         = "layer",
  msigdb_species       = "Homo sapiens",
  msigdb_collections   = c("H","C2","C5"),
  msigdb_subcategories = c("CP:KEGG","GO:BP"),
  results_dir          = getOption("mlnet.results_dir","omicsDNA_results"),
  run_name             = "gsea_pairs_byLayer",
  top_n                = 10,
  format               = "png",
  show_in_rstudio      = TRUE
)

## 2) Layer-pair GSEA restricted to a custom gene set ---------------------
gsea_layer_pairs_custom <- gsea_msigdbr_layer_pairs(
  net                  = net,
  layer_order          = multinet::layers_ml(net),
  enrich_scope         = "layer",
  restrict_genes       = oxidative_stress_genes,   # only these genes
  msigdb_species       = "Homo sapiens",
  msigdb_collections   = c("H","C2"),
  msigdb_subcategories = c("CP:KEGG"),
  results_dir          = getOption("mlnet.results_dir","omicsDNA_results"),
  run_name             = "gsea_pairs_byLayer_customGenes",
  top_n                = 10,
  format               = "png",
  show_in_rstudio      = TRUE
)

## 3) Community-wise pair GSEA (all genes per community) ------------------
gsea_comm_pairs <- gsea_msigdbr_layer_pairs(
  net                  = net,
  communities          = comm,                    # actor / layer / cid
  enrich_scope         = "community",
  msigdb_species       = "Homo sapiens",
  msigdb_collections   = c("H","C2","C5"),
  msigdb_subcategories = c("CP:KEGG","GO:BP"),
  results_dir          = getOption("mlnet.results_dir","omicsDNA_results"),
  run_name             = "gsea_pairs_byCommunity",
  top_n                = 8,
  format               = "png",
  show_in_rstudio      = TRUE
)

## 4) Community-wise pair GSEA restricted to a custom gene set ------------
gsea_comm_pairs_ox <- gsea_msigdbr_layer_pairs(
  net                  = net,
  communities          = comm,
  enrich_scope         = "community",
  restrict_genes       = oxidative_stress_genes,
  msigdb_species       = "Homo sapiens",
  msigdb_collections   = c("H","C2","C5"),
  msigdb_subcategories = c("CP:KEGG","GO:BP"),
  results_dir          = getOption("mlnet.results_dir","omicsDNA_results"),
  run_name             = "gsea_pairs_byCommunity_customGenes",
  top_n                = 8,
  format               = "png",
  show_in_rstudio      = TRUE
)

## Look at the manifest:
# read.csv(gsea_layer_pairs$summary_file, stringsAsFactors = FALSE)
}
}
