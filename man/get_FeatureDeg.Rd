% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/get_FeatureDeg.R
\name{get_FeatureDeg}
\alias{get_FeatureDeg}
\title{Degrees for a selected feature set across layers (robust, \pkg{igraph}-based)}
\usage{
get_FeatureDeg(
  net,
  featureList,
  layers = NULL,
  directed = FALSE,
  mode = "all",
  actor_normalize = c("strip_version", "trim", "tolower"),
  write_csv = FALSE,
  output_file = "features-degree_byLayer.csv",
  results_dir = getOption("mlnet.results_dir", "omicsDNA_results"),
  return_long = FALSE,
  verbose = TRUE
)
}
\arguments{
\item{net}{A \pkg{multinet} object (must work with \code{multinet::edges_ml()}).}

\item{featureList}{Character vector of actor names to measure (duplicates are
ignored; input order is preserved in the output).}

\item{layers}{Optional character vector of layer names to include. Default:
all layers found in \code{edges_ml(net)} after intra‑layer filtering.}

\item{directed}{Logical; build directed per‑layer graphs? Default \code{FALSE}.}

\item{mode}{Degree mode used when \code{directed = TRUE}: one of \code{"all"} (default),
\code{"in"}, or \code{"out"}. Ignored when \code{directed = FALSE}.}

\item{actor_normalize}{Character vector of normalisation steps applied to both
sides before matching (\code{"strip_version"}, \code{"trim"}, \code{"tolower"}, \code{"toupper"},
\code{"rm_dash"}, \code{"rm_punct"}, \code{"alnum"}). Default
\code{c("strip_version","trim","tolower")}.}

\item{write_csv}{Logical; if \code{TRUE}, write a CSV (wide by default; long if
\code{return_long = TRUE}). Default \code{FALSE}.}

\item{output_file}{File name for the CSV. If relative, it is saved under
\code{getOption("mlnet.results_dir","omicsDNA_results")}. If \code{NULL} or left as
the default placeholder (\code{"features-degree_byLayer.csv"}), an informative,
timestamped name is generated automatically in that folder.}

\item{results_dir}{Directory used when \code{output_file} is relative or
auto‑generated. Default \code{getOption("mlnet.results_dir","omicsDNA_results")}.}

\item{return_long}{Logical; return long format (\code{Layer}, \code{Feature}, \code{Degree})?
Default \code{FALSE} (wide).}

\item{verbose}{Logical; print the saved file path when writing. Default \code{TRUE}.}
}
\value{
A data frame of degrees by layer × feature:
\itemize{
\item \strong{Wide} (default): columns \code{Layer}, \verb{<Feature1>}, \verb{<Feature2>}, …
\item \strong{Long} (\code{return_long = TRUE}): columns \code{Layer}, \code{Feature}, \code{Degree}.
If \code{write_csv = TRUE}, the absolute file path is attached as \code{attr(x, "file")}.
}
}
\description{
Compute per‑layer \strong{degrees} for an arbitrary set of actors (e.g., genes of
interest). The function extracts all \strong{intra‑layer} edges from a
\pkg{multinet} object, builds one \pkg{igraph} graph per layer, and reports
each requested actor’s degree in that layer. Actors not present in a given
layer are added as \strong{isolates} so their degree is reported as \code{0} rather than
\code{NA}. Results can be returned in \strong{wide} (default) or \strong{long} shape and
optionally written to a timestamped CSV in your project results folder.
}
\details{
\strong{Input normalisation and scope}
\itemize{
\item Edges are retrieved once via \code{multinet::edges_ml(net)} and coerced to a data
frame. If \code{from_layer} and \code{to_layer} exist, only \strong{intra‑layer} edges are
kept (\code{from_layer == to_layer}) and a single \code{layer} column is created from
\code{from_layer}. Otherwise an existing \code{layer}/\code{Layer} column is used; if none
exists, a single layer \code{"L1"} is assumed.
\item Endpoint columns are identified robustly by name (tries common pairs such as
\code{from}/\code{to}, \code{source}/\code{target}, \code{actor1}/\code{actor2}). If these are absent, the
\strong{first two character columns} (excluding layer‑like columns) are used.
}

\strong{Actor matching and normalisation}
\itemize{
\item Actor names in \code{featureList} are matched to vertex names per layer using the
same normalisation pipeline you use elsewhere (default:
\code{c("strip_version","trim","tolower")}), applied via the helper
\code{.normalize_keys()}. This improves robustness to minor ID formatting
differences.
}

\strong{Degree definition}
\itemize{
\item Degrees are computed with \code{igraph::degree()} and \code{loops = FALSE}.
\item When \code{directed = FALSE} (default), mode is effectively \code{"all"}. When
\code{directed = TRUE}, \code{mode} can be \code{"all"}, \code{"in"}, or \code{"out"}.
}

\strong{Output shape and persistence}
\itemize{
\item By default (\code{return_long = FALSE}), a \strong{wide} table is returned with one
row per \code{Layer} and one column per \code{Feature}. If \pkg{tidyr} is available,
reshaping is done with \code{pivot_wider}; otherwise a base‑R fallback is used.
\item With \code{return_long = TRUE}, a \strong{long} table is returned with columns
\code{Layer}, \code{Feature}, \code{Degree}.
\item If \code{write_csv = TRUE}, results are written under
\code{getOption("mlnet.results_dir","omicsDNA_results")} when \code{output_file} is a
relative path or left as the default placeholder (a timestamped name is
then generated automatically). Absolute paths are respected. The absolute
file path is attached as \code{attr(x, "file")}.
}

\strong{Caveats}
\itemize{
\item The heuristic for endpoint detection (first two character columns) can be
fooled if your edge table contains other character columns before the
endpoints; reorder columns upstream when in doubt.
}
}
\examples{
\dontrun{
# 1) lncRNAs across all layers, undirected (wide) + save under results dir
lnc_list  <- unique(subset(comm_annot, GeneType == "lncRNA")$actor)
all_layers <- multinet::layers_ml(net)
deg_lnc <- get_FeatureDeg(
  net, featureList = lnc_list, layers = all_layers,
  directed   = FALSE, mode = "all",
  write_csv  = TRUE,
  output_file = "lncRNA_degree_byLayer.csv"
)

# 2) Protein‑coding, long shape (no file)
pc_list <- unique(subset(comm_annot, GeneType == "protein_coding")$actor)
deg_pc  <- get_FeatureDeg(
  net, featureList = pc_list, layers = all_layers,
  return_long = TRUE
)

# 3) Directed in‑degree for a custom list on selected layers
sel_layers <- c("Young","Old")
deg_in <- get_FeatureDeg(
  net, featureList = c("TP53","MYC","EGFR"),
  layers = sel_layers, directed = TRUE, mode = "in"
)
}

}
\seealso{
\code{\link{layer_metrics}} for broader per‑layer summaries;
\code{\link{sumComFeat}} and \code{\link{annotateCom}} for feature‑aware
community summaries and annotations.
}
