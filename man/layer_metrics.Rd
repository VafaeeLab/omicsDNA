% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/layer_metrics.R
\name{layer_metrics}
\alias{layer_metrics}
\title{Compute per‑layer network and node metrics, and save results to a run folder:}
\usage{
layer_metrics(
  net,
  layers = NULL,
  directed = FALSE,
  file_prefix = "layer_metrics",
  verbose = TRUE
)
}
\arguments{
\item{net}{A multilayer network compatible with
\code{multinet::edges_ml()} (and typically \code{multinet::layers_ml()}).}

\item{layers}{Optional character vector of layer names to analyse. Default
\code{NULL} (analyse \strong{all} layers found after intra‑layer filtering).}

\item{directed}{Logical; build directed graphs (\code{TRUE}) or undirected graphs
(\code{FALSE}). Default \code{FALSE}.}

\item{file_prefix}{Basename used for the run folder and output files inside it.
Default \code{"layer_metrics"}.}

\item{verbose}{Logical; print per‑layer progress and file paths. Default \code{TRUE}.}
}
\value{
Invisibly returns a list with:
\itemize{
\item \code{summary} — data frame with one row per layer and the layer‑level metrics;
\item \code{nodes}   — named list of data frames (node‑level metrics per layer);
\item \code{paths}   — list of absolute paths: \code{run_dir}, \code{summary_csv}, and either
\code{nodes_xlsx} (when \strong{writexl} is available) or \code{per_layer_dir} (CSV folder).
}
}
\description{
Builds an \pkg{igraph} graph for each layer of a \pkg{multinet} object,
computes a standard set of \strong{node‑level} and \strong{layer‑level} metrics, and
writes all artefacts into a timestamped run folder. This is designed to be a
drop‑in analysis step you can re‑run reproducibly.
}
\details{
\strong{Input normalisation and scope}
\itemize{
\item Edges are retrieved once via \code{multinet::edges_ml(net)} and coerced to a data
frame. If both \code{from_layer} and \code{to_layer} are present, \strong{only intra‑layer}
edges are kept (\code{from_layer == to_layer}) and a single \code{layer} column is set
to \code{from_layer}. Otherwise, an existing \code{layer}/\code{Layer} column is used; if
neither exists, a single layer \code{"L1"} is assumed.
\item Endpoint columns are identified robustly by name (tries common pairs such as
\code{from}/\code{to}, \code{source}/\code{target}, \code{actor1}/\code{actor2}). If these are not found,
the \strong{first two character columns} (excluding obvious layer columns) are
used as endpoints.
}

\strong{Graph construction and directedness}
\itemize{
\item For each selected layer, an \pkg{igraph} object is created with vertices
defined by the endpoints appearing in that layer’s edges. If \code{directed = TRUE},
a directed graph is built and passed to all directed‑aware metrics; otherwise
an undirected graph is used.
}

\strong{Node‑level metrics (per layer)}
\itemize{
\item \code{degree} (mode \code{"all"}; for directed graphs this is in + out),
\item \code{betweenness} (normalised; respects \code{directed}),
\item \code{eigenvector} centrality (scaled; respects \code{directed}; errors are caught and
return \code{NA}),
\item \code{closeness} (mode \code{"all"}; non‑finite values coerced to \code{0}),
\item \code{pagerank} (respects \code{directed}; returns the PageRank vector),
\item local \code{clustering} coefficient (\code{transitivity(type = "local", isolates = "zero")}),
\item \code{coreness} (k‑core index; mode \code{"all"}).
}

\strong{Layer‑level summaries}
\itemize{
\item \code{n_nodes}, \code{n_edges}, \code{density} (\code{edge_density(loops = FALSE)}),
\item number of weak components (\code{components(mode = "weak")}),
\item \code{avg_path_len} and \code{diameter} with \code{unconnected = TRUE} (guarded by \code{tryCatch};
may return \code{NA} on degenerate graphs),
\item degree distribution summaries: \code{mean}, \code{sd}, \code{median}, \code{min}, \code{max},
coefficient of variation (\code{sd/mean}, \code{NA} if mean = 0), and \strong{skewness}
(third central moment over \code{sd^3}; requires \verb{n ≥ 3}, otherwise \code{NA}).
}

\strong{Saving strategy (run‑folder style)}
\itemize{
\item Uses the global results directory \code{getOption("mlnet.results_dir", "omicsDNA_results")}.
\item Creates a \strong{run‑specific subfolder} named
\code{"<file_prefix>_<YYYY-mm-dd_HHMMSS>"} inside that directory.
\item Writes:
\itemize{
\item \code{layer_metrics_summary.csv} (one row per layer);
\item node metrics either as a single workbook
\code{layer_metrics_nodes.xlsx} (one sheet per layer; requires \strong{writexl}),
\strong{or} as \verb{nodes_per_layer_csv/} containing one CSV per layer.
}
}

\strong{Notes}
\itemize{
\item All metrics are computed on \strong{unweighted} graphs. If weighted metrics are
needed, extend the \pkg{igraph} calls accordingly.
\item Layers with no nodes/edges yield empty node tables and \code{NA} layer summaries
where appropriate.
}
}
\examples{
\dontrun{
# Optionally set your project results folder once:
# options(mlnet.results_dir = "/path/to/results")

out <- layer_metrics(net)  # writes to omicsDNA_results/layer_metrics_<stamp>/
out$summary[, c("layer","n_nodes","n_edges","density")]
head(out$nodes[[ out$summary$layer[1] ]])
out$paths
}

}
\seealso{
\code{\link{detectCom}} for community detection prior to metric summaries;
\code{\link{build_multiNet}} for assembling multilayer networks.
}
