% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/edgesFromAdjacency.R
\name{edgesFromAdjacency}
\alias{edgesFromAdjacency}
\title{Turn adjacency matrices (single or nested) into tidy edge lists}
\usage{
edgesFromAdjacency(
  x,
  directed = FALSE,
  drop_zeros = TRUE,
  min_abs = NULL,
  na_rm = TRUE,
  flatten = FALSE,
  id_cols = NULL,
  save_to_rds = TRUE,
  rds_file = NULL,
  results_dir = getOption("mlnet.results_dir", "omicsDNA_results"),
  verbose = TRUE
)
}
\arguments{
\item{x}{Numeric square matrix (adjacency), a sparse Matrix, or a (possibly nested)
list of such matrices.}

\item{directed}{Logical; if \code{FALSE} use upper triangle (no self‑loops); if \code{TRUE}
include all off‑diagonal pairs. Default \code{FALSE}.}

\item{drop_zeros}{Logical; drop edges with weight exactly 0 (dense matrices).
Default \code{TRUE}. For sparse matrices, zeros are not stored and thus never appear.}

\item{min_abs}{Optional numeric; keep edges with \code{abs(weight) >= min_abs}. Default \code{NULL}.}

\item{na_rm}{Logical; drop edges with \code{NA} weights. Default \code{TRUE}.}

\item{flatten}{Logical; when \code{x} is a list, return a single data frame with
identifier columns instead of preserving the list structure. Default \code{FALSE}.}

\item{id_cols}{Character vector naming the list levels when \code{flatten = TRUE}.
Length must equal the maximum nesting depth of \code{x}. If \code{NULL}, defaults to
\code{level1..levelK}. Default \code{NULL}.}

\item{save_to_rds}{Logical; save the returned edge list(s) as an RDS file. Default \code{TRUE}.}

\item{rds_file}{File name to use when saving. If \code{NULL}, an informative name is
created automatically. Relative names are placed under \code{results_dir}; absolute
paths are respected. Default \code{NULL}.}

\item{results_dir}{Output directory for saved files. Default
\code{getOption("mlnet.results_dir", "omicsDNA_results")}.}

\item{verbose}{Logical; print progress/messages. Default \code{TRUE}.}
}
\value{
\itemize{
\item If \code{x} is a matrix: a data frame with columns \code{from}, \code{to}, \code{weight}.
\item If \code{x} is a list: a list (same shape) of data frames, or a single data frame
when \code{flatten = TRUE} (with \code{id_cols} prepended).
}
}
\description{
Convert one adjacency matrix, a list of matrices, or a nested list of matrices
into data frame(s) of edges with columns \code{from}, \code{to}, and \code{weight}. Works with
dense base matrices and sparse matrices from the \strong{Matrix} package. Supports
directed/undirected output, filtering, and optional flattening of nested inputs.
}
\details{
\strong{Directed vs. undirected}
\itemize{
\item \code{directed = FALSE} (default): return one edge per unordered pair (upper triangle),
excluding self‑loops.
\item \code{directed = TRUE}: return all off‑diagonal pairs.
}

\strong{Filtering}
\itemize{
\item Use \code{drop_zeros}, \code{min_abs}, and \code{na_rm} to remove edges. The sign of \code{weight}
is preserved.
}

\strong{Sparse input}
\itemize{
\item Sparse matrices (\code{dgCMatrix}, \code{dsCMatrix}, …) are handled efficiently by
enumerating only stored (non‑zero) entries. Note that explicit zeros are not
stored in sparse formats; therefore \code{drop_zeros = FALSE} will not add zeros.
\item Matrices are expected to be square (enforced for dense matrices and assumed
for sparse matrices).
}

\strong{Lists and nesting}
\itemize{
\item If \code{x} is a list (possibly nested), the output can either preserve the list
shape (default) or be flattened into one tidy data frame. For flattened output,
supply \code{id_cols} to name the list levels (e.g., \code{c("repeat","group")}). If
\code{id_cols} is omitted, generic names \code{level1..levelK} are used. Ragged nesting
is supported; missing levels are filled with \code{NA}.
}

\strong{Persistence}
\itemize{
\item When \code{save_to_rds = TRUE}, the result is saved under \code{results_dir}. If \code{x} is
a matrix the file name is \verb{edges_df_<timestamp>.rds}; if a flattened list,
\verb{edges_flat_<timestamp>.rds}; otherwise \verb{edges_list_<timestamp>.rds}. If you
provide \code{rds_file}, a relative path is placed under \code{results_dir}, while an
absolute path is respected.
}
}
\examples{
# Dense matrix
A <- matrix(c(0, 0.8, 0.8, 0), 2, 2, dimnames = list(c("a","b"), c("a","b")))
edgesFromAdjacency(A)

# Per‑group list, flattened with a label
L <- list(G1 = A, G2 = A * 0.5)
edgesFromAdjacency(L, flatten = TRUE, id_cols = "group")

# Nested list: repeat -> group (ragged OK)
NL <- list(`1` = list(E1 = A, E2 = A), `2` = list(E1 = A))
edgesFromAdjacency(NL, flatten = TRUE, id_cols = c("repeat","group"))

}
\seealso{
\code{\link{buildAdjacency}} to build group‑wise adjacency matrices.
}
