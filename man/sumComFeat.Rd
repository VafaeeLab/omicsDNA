% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/sumComFeat.R
\name{sumComFeat}
\alias{sumComFeat}
\title{Summarise community membership for selected feature types (pure data‑frame workflow)}
\usage{
sumComFeat(
  communities,
  feature_col = "GeneType",
  feature_type,
  layers = NULL,
  ignore_case = FALSE,
  actor_normalize = c("strip_version", "trim", "tolower"),
  write_csv = FALSE,
  prefix = NULL,
  results_dir = getOption("mlnet.results_dir", "omicsDNA_results"),
  verbose = TRUE
)
}
\arguments{
\item{communities}{Data frame with at least: \code{actor} (or \code{GeneName}),
\code{layer}, one of \code{cid} or \code{com}, and the feature attribute column named by
\code{feature_col}.}

\item{feature_col}{Character scalar; name of the feature attribute column in
\code{communities} used for filtering (e.g., \code{"GeneType"}). Default \code{"GeneType"}.}

\item{feature_type}{Character vector of feature values to keep
(e.g., \code{c("lncRNA", "TF")}). Required.}

\item{layers}{Optional character vector of layer names to retain. Default \code{NULL}
(use all layers present).}

\item{ignore_case}{Logical; if \code{TRUE}, compare \code{feature_type} to \code{feature_col}
values case‑insensitively. Default \code{FALSE}.}

\item{actor_normalize}{Character vector of normalisation steps used to build
\code{actor_clean} for display ordering (does \strong{not} affect grouping or counts).
Supported steps: \code{"strip_version"}, \code{"trim"}, \code{"tolower"}, \code{"toupper"},
\code{"rm_dash"}, \code{"rm_punct"}, \code{"alnum"}. Default \code{c("strip_version","trim","tolower")}.}

\item{write_csv}{Logical; if \code{TRUE}, write the three CSVs described above.
Default \code{FALSE}.}

\item{prefix}{Optional filename stem for the CSVs. If \code{NULL}, a stem is
auto‑generated from \code{feature_col} and \code{feature_type} (sanitised).}

\item{results_dir}{Output directory for CSVs when \code{write_csv = TRUE}. Default
\code{getOption("mlnet.results_dir", "omicsDNA_results")}.}

\item{verbose}{Logical; print short status messages (e.g., saved file paths).
Default \code{TRUE}.}
}
\value{
(Invisibly) a list with three data frames:
\itemize{
\item \code{by_actor} — per‑actor membership summary,
\item \code{by_cid} — per‑community composition summary,
\item \code{counts_cid_layer} — unique‑actor counts by community × layer.
}
If \code{write_csv = TRUE}, the list has an attribute \code{"files"} containing absolute
paths to the three CSVs.
}
\description{
Filter a community assignment table (e.g., from \code{detectCom()} plus your
node‑metadata merge) to one or more \strong{feature types} (e.g., \code{"lncRNA"},
\code{"protein_coding"}, \code{"TF"}), then produce three concise summaries:
(1) \strong{per‑actor} membership across communities and layers;
(2) \strong{per‑community} composition (actors and layers); and
(3) \strong{counts} of unique actors per \verb{CID × layer}.
This function does \strong{not} call \pkg{multinet}: it operates purely on data
frames, making it fast, reproducible, and script‑friendly.
}
\details{
\strong{Input expectations and harmonisation}
\itemize{
\item \code{communities} must contain:
\itemize{
\item an actor/ID column: preferably \code{actor}; if missing, \code{GeneName} is copied to \code{actor};
\item a \code{layer} column; and
\item either \code{cid} \strong{or} \code{com}. If only \code{com} is present, a numeric \code{cid} is
generated via \code{as.integer(factor(com))}. If only \code{cid} is present, a label
\code{com = paste0("C", cid)} is generated.
}
\item A feature attribute column named in \code{feature_col} (e.g., \code{"GeneType"}) must
be present; it is used for the type filter.
}

\strong{Filtering and normalisation}
\itemize{
\item Rows are kept only if their \code{feature_col} value is in \code{feature_type}
(optionally case‑insensitive via \code{ignore_case}). You may further restrict to
a subset of \code{layers}.
\item An auxiliary \code{actor_clean} is created via \code{.normalize_keys()} using
\code{actor_normalize} (default \code{c("strip_version","trim","tolower")}) \strong{only to
provide a deterministic display order}; it does not affect grouping or counts.
}

\strong{Outputs produced}
\enumerate{
\item \strong{Per‑actor summary} (\code{by_actor}): columns
\verb{actor, CIDs, Layers, n_cids, n_layers}, ordered by \code{actor_clean}.
\item \strong{Per‑community summary} (\code{by_cid}): columns
\verb{cid, com, Features, Layers, n_features, n_layers}, where \code{Features}
is a comma‑separated list of unique actor IDs belonging to the community
(after filtering), and \code{Layers} lists the layers in which those actors occur.
\item \strong{Counts by community × layer} (\code{counts_cid_layer}): columns
\verb{cid, com, layer, n}, where \code{n} is the number of \strong{unique actors} in that
community‑layer slice.
}

\strong{Saving to disk}
\itemize{
\item When \code{write_csv = TRUE}, three timestamped CSVs are written under
\code{results_dir} (default:
\code{getOption("mlnet.results_dir", "omicsDNA_results")}), with file stems
derived from \code{prefix} (or, if missing, from \code{feature_col} and \code{feature_type}):
\code{"<prefix>_by-actor_<timestamp>.csv"},
\code{"<prefix>_by-cid_<timestamp>.csv"},
\code{"<prefix>_counts_cid-layer_<timestamp>.csv"}.
\item The returned list then carries an attribute \code{"files"} with the absolute
paths of the three CSVs.
}

\strong{Behaviour on empty selections}
\itemize{
\item If no rows remain after the type/layer filters or required columns are
missing, the function raises an informative error.
}
}
\examples{
\dontrun{
# Keep TFs and lncRNAs across all layers, then write summaries to disk
out <- sumComFeat(
  communities   = comm_annot,        # e.g., detectCom() + annotateCom()
  feature_col   = "GeneType",
  feature_type  = c("TF", "lncRNA"),
  write_csv     = TRUE
)
out$by_actor[1:5, ]
out$by_cid[1:5, ]
out$counts_cid_layer[1:5, ]
attr(out, "files")
}

}
\seealso{
\code{\link{annotateCom}} to add feature annotations before summarising;
\code{\link{detectCom}} to generate community assignments.
}
