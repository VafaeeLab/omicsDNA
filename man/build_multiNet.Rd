% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/build_multiNet.R
\name{build_multiNet}
\alias{build_multiNet}
\title{Build a multilayer network from per‑layer edge tables or adjacency matrices}
\usage{
build_multiNet(
  edgeListPerLayer,
  nodesMetadata = NULL,
  featureID_col = "feature_id",
  nodeAttrCols = NULL,
  layerOrder = NULL,
  directed = FALSE,
  verbose = TRUE,
  layer_col = NULL,
  rep_col = NULL,
  rep_filter = NULL,
  list_order = c("auto", "layer_rep", "rep_layer"),
  rep_collapse = c("mean", "median", "sum", "none"),
  aggregate_duplicates = c("none", "mean", "median", "sum"),
  results_dir = getOption("mlnet.results_dir", "omicsDNA_results"),
  save_to_rds = TRUE,
  rds_file = NULL,
  save_layers_graphml = FALSE,
  graphml_prefix = "layer"
)
}
\arguments{
\item{edgeListPerLayer}{A named list of per‑layer edge data frames; or a
flattened edge data frame; or a single adjacency matrix; or a (nested) list
of adjacency matrices. Edge data frames must contain \code{from}, \code{to}, and
optional \code{weight} (defaulted to \code{1} if missing). Adjacency inputs require
\code{edgesFromAdjacency()}.}

\item{nodesMetadata}{Optional data frame of node attributes. Its identifier
column must be named in \code{featureID_col} and must match the vertex names used
in the edges.}

\item{featureID_col}{Name of the identifier column in \code{nodesMetadata} used to
match attributes to vertices. Default \code{"feature_id"}.}

\item{nodeAttrCols}{Character vector naming columns of \code{nodesMetadata} to
attach as vertex attributes. If \code{NULL} and \code{nodesMetadata} is provided, all
columns except \code{featureID_col} are attached.}

\item{layerOrder}{Optional character vector of layer names. If supplied, only
these layers are retained and they are ordered accordingly; otherwise layers
are ordered alphabetically.}

\item{directed}{Logical; whether per‑layer graphs are directed. Default \code{FALSE}.}

\item{verbose}{Logical; print per‑layer summaries (vertex counts and attribute
match coverage) and file‑saving messages. Default \code{TRUE}.}

\item{layer_col, rep_col}{For flattened data‑frame input only: explicit column
names for layer and repetition identifiers. If \code{NULL}, they are auto‑detected
as described above.}

\item{rep_filter}{Optional vector (labels or numeric indices over the unique
repetition labels) selecting which repetitions to keep for flattened input.}

\item{list_order}{For nested lists: \code{"auto"}, \code{"layer_rep"} (top level indexes
layers), or \code{"rep_layer"} (top level indexes repetitions). Default \code{"auto"}.}

\item{rep_collapse}{How to combine multiple repetitions within each layer when
present and not filtered. One of \code{"mean"}, \code{"median"}, \code{"sum"}, \code{"none"}.
Default \code{"mean"}.}

\item{aggregate_duplicates}{How to combine duplicate \code{from}–\code{to} rows within a
layer \strong{after} repetition handling. One of \code{"none"}, \code{"mean"}, \code{"median"},
\code{"sum"}. Default \code{"none"}.}

\item{results_dir}{Directory to write outputs. Default
\code{getOption("mlnet.results_dir", "omicsDNA_results")}.}

\item{save_to_rds}{Logical; save the \code{ml.network} object as an RDS file under
\code{results_dir}. Default \code{TRUE}.}

\item{rds_file}{Optional filename for the RDS. If relative, it is created
under \code{results_dir}; absolute paths are respected. Default \code{NULL} (auto‑named
with a timestamp).}

\item{save_layers_graphml}{Logical; also export each layer as a GraphML file.
Default \code{FALSE}.}

\item{graphml_prefix}{Basename prefix for per‑layer GraphML files (layer name
and a timestamp are appended).}
}
\value{
A \code{multinet::ml.network} object containing one layer per group/condition.
}
\description{
This routine constructs a multilayer network—one layer per group/condition—
and returns a \code{multinet::ml.network}. It is designed to accept the most common
representations used in practice and to normalise them into the structure that
\code{multinet} expects.

\strong{Accepted input formats}
\itemize{
\item \strong{Per‑layer edge tables:} a \strong{named list} where each element is a data
frame containing \code{from}, \code{to}, and (optionally) \code{weight}.
\item \strong{Flattened edge table:} a single data frame with columns \code{from}, \code{to},
optional \code{weight}, a layer column (auto‑detected), and optional repetition
column (also auto‑detected).
\item \strong{Adjacency matrices:} a single square matrix, a list of matrices (one per
layer), or a nested list (repeat × layer or layer × repeat). These are
first converted to edge tables via \code{edgesFromAdjacency()} (which must be
available when using adjacency inputs).
}
}
\details{
\strong{Workflow and internal logic}
\enumerate{
\item \strong{Normalisation to a layer‑indexed list.} Regardless of the input form,
the function produces a \strong{named list keyed by layer}, with each element a
tidy data frame of \code{from}, \code{to}, \code{weight}.
\itemize{
\item For \strong{flattened tables}, the function detects the layer column from
\code{c("layer","Layer","group","Group")}. The repetition column (if present)
is detected from \code{c("rep","repeat","repetition","bootstrap","iter", "iteration","Rep","Repeat")}. If not found, repetitions default to a
single level \code{"1"}.
\item For \strong{nested lists}, the option \code{list_order} controls whether the top
level indexes \strong{layers} or \strong{repetitions}. With \code{list_order = "auto"},
the function inspects names to infer a sensible layout. Lists deeper than
two levels are not supported for adjacency inputs.
}
\item \strong{Handling repetitions (optional).} If a repetition column is present in
a flattened table, you may either:
\itemize{
\item \strong{Filter repetitions} with \code{rep_filter} (named labels or numeric indices
over the unique repetition labels), or
\item \strong{Collapse repetitions within each layer} using \code{rep_collapse}
(\code{"mean"}, \code{"median"}, \code{"sum"}, or \code{"none"}). When \code{"none"}, rows from
different repetitions are kept as‑is; duplicates may therefore persist to
the next step.
}
\item \strong{Directedness and duplicate aggregation.} For \strong{undirected} layers
(\code{directed = FALSE}), endpoints are canonicalised prior to deduplication
(\code{from = pmin(from,to)}, \code{to = pmax(from,to)}), ensuring \verb{A–B} and \verb{B–A}
are treated as the same edge. Duplicate \code{from}–\code{to} rows \strong{within a layer}
are combined according to \code{aggregate_duplicates} (\code{"none"}, \code{"mean"},
\code{"median"}, \code{"sum"}). If \code{"none"}, multiple parallel edges may be created
in the resulting \code{igraph} layer.
\item \strong{Per‑layer graph construction.} Each layer is converted to an \code{igraph}
object via \code{igraph::graph_from_data_frame()}. Edge weights default to \code{1}
when missing and are coerced to numeric.
\item \strong{Node attributes (optional).} If \code{nodesMetadata} is supplied, vertex
attributes are attached by matching \code{nodesMetadata[[featureID_col]]} to the
vertex names. When \code{nodeAttrCols = NULL}, all columns except \code{featureID_col}
are attached. Unmatched vertices receive \code{NA} for those attributes.
\item \strong{Assembly of the multilayer object.} The per‑layer \code{igraph}s are inserted
into a new \code{multinet::ml.network} using \code{multinet::add_igraph_layer_ml()}.
}

\strong{Layer ordering and naming}
\itemize{
\item If \code{layerOrder} is \strong{not} provided, layers are ordered alphabetically by
their names. If \code{layerOrder} \strong{is} provided, only the listed layers are
kept and they appear in the specified order.
}

\strong{Notes and limitations}
\itemize{
\item Vertices appear only if referenced by at least one edge in that layer. If
you require isolates, add them upstream (e.g., by inserting zero‑weight
self‑loops or extending this function to accept an explicit vertex set).
\item When using \strong{adjacency} inputs, this function relies on
\code{edgesFromAdjacency()}. For sparse matrices, zeros are not stored; hence a
zero entry will not generate an edge.
}

\strong{Persistence and exports}
\itemize{
\item When \code{save_to_rds = TRUE}, the multilayer network is saved as an RDS file
under \code{results_dir} (default:
\code{getOption("mlnet.results_dir", "omicsDNA_results")}). The filename is
auto‑generated unless \code{rds_file} is provided (relative paths are resolved
under \code{results_dir}; absolute paths are respected).
\item Setting \code{save_layers_graphml = TRUE} additionally writes each layer as a
GraphML file using \code{igraph::write_graph()}, with filenames prefixed by
\code{graphml_prefix}, suffixed by the layer name and a timestamp.
}
}
\examples{
\dontrun{
## From consensusEdges(..., as_list = TRUE):
net <- build_multiNet(
  cons_list,
  nodesMetadata   = genes_info,
  featureID_col   = "GeneName",
  nodeAttrCols    = "GeneType",
  directed        = FALSE,
  aggregate_duplicates = "mean"
)

## From flattened edges (e.g., edgesFromAdjacency(..., flatten = TRUE)):
net <- build_multiNet(
  edges_df,
  rep_collapse    = "median"
)

## From adjacency matrices (list[layer] or nested repeat × layer):
net <- build_multiNet(
  adjacency,
  list_order      = "rep_layer"
)
}

}
\seealso{
\code{\link{edgesFromAdjacency}} for converting adjacencies to edge tables;
\code{\link{consensusEdges}} for obtaining stable, per‑layer edge sets.
}
