
# ------------------------------------------------------------------------------
# 3 - Consensus edges across repetitions (general; accepts tidy df, list of edges,
# list of adjacencies; saves to results/)
# ------------------------------------------------------------------------------

#' Consensus edges across repetitions (works with tidy data, edge lists, or adjacencies)
#'
#' Identify edges that reproducibly occur across repeated networks within each
#' layer (e.g., age group, condition), then summarise their weights across
#' repetitions. The procedure is domain‑agnostic and applies equally to
#' co‑expression graphs, interaction networks, or infrastructure graphs.
#'
#' @description
#' **Inputs accepted**
#' - A tidy `data.frame` with columns `from`, `to`, `weight`, plus layer and
#'   (optionally) repetition identifiers; or
#' - A (possibly nested) `list` of edge data frames; or
#' - A (possibly nested) `list` of adjacency matrices (base or sparse). Adjacencies
#'   are first converted with `edgesFromAdjacency()` (which must be available).
#'
#' **Pre‑filter applied for list inputs (Option B)**
#' - Within each iteration, **remove only empty layer snapshots** (0‑row edge
#'   frames or 0‑edge adjacencies) and report the removal.
#' - After that, if a layer appears with ≥1 edge in **< 20%** of iterations,
#'   **drop the layer entirely** and report it (prevents downstream raggedness).
#'
#' **How it works (per layer)**
#' 1. Normalise the input into a tidy table with columns `layer`, `rep`, `from`,
#'    `to`, `weight`. For nested lists, the **last** list level is treated as
#'    `layer`; all higher levels are collapsed into a single `rep` label joined
#'    by `"|"`.
#' 2. If `directed = FALSE` (default), canonicalise endpoints so `A–B == B–A`.
#'    If `keep_self_loops = FALSE` (default), drop `from == to`.
#' 3. Within each `(layer, rep, from, to)` combination, average duplicate rows by
#'    **mean** (`na.rm = TRUE`) to obtain one weight per repetition.
#' 4. Count, for each edge `(from, to)`, in how many repetitions it appears.
#'    Keep the edge if it meets the presence criterion: at least `min_reps`
#'    repetitions (if provided), otherwise at least
#'    `ceiling(prop_present * n_repeats)` (with a minimum of 1).
#' 5. For the kept edges, summarise their weights **across repetitions** using
#'    either `"mean"`, `"median"`, or a user‑supplied function; `na_rm` controls
#'    how missing weights are handled in this summary step.
#'
#' **Layer/rep auto‑detection (data.frame input)**
#' - The layer column is required and auto‑detected from one of
#'   `layer`, `Layer`, `group`, `Group`. If none is found, set `layer_col`.
#' - The repetition column is optional and auto‑detected from one of
#'   `rep`, `repeat`, `repetition`, `bootstrap`, `iter`, `iteration`, `Rep`, `Repeat`.
#'   If none is found, repetitions are assumed to be `"1"`.
#'
#' **Notes on adjacency inputs**
#' - Conversion relies on `edgesFromAdjacency()`. For sparse matrices, only
#'   stored (non‑zero) entries are enumerated. Zeros are not stored in sparse
#'   formats and cannot be recovered by setting `drop_zeros = FALSE`.
#'
#' **Output**
#' - If `as_list = TRUE`: a named list (one data frame per layer), each with
#'   columns `from`, `to`, `weight` (summarised across repetitions),
#'   `n_present`, `n_repeats`, and `prop_present`.
#' - If `as_list = FALSE`: a single tidy data frame with the same columns plus
#'   a `layer` column.
#'
#' **Persistence**
#' - When `save_to_rds = TRUE`, results are written under `results_dir`. Filenames
#'   are auto‑generated by type: `consensus_list_<timestamp>.rds` for lists or
#'   `consensus_df_<timestamp>.rds` for a single data frame. If `rds_file` is
#'   given, a relative path is placed under `results_dir` and an absolute path
#'   is respected. Optional per‑layer CSVs (`write_csv = TRUE`) and a single
#'   XLSX export (`write_xlsx = TRUE`, requires **writexl**) are supported.
#'
#' @param edges A tidy `data.frame`, or a (nested) list of edge data frames, or a
#'   (nested) list of adjacency matrices.
#' @param prop_present Numeric in (0, 1]; minimum fraction of repetitions (per
#'   layer) that must contain an edge when `min_reps` is not supplied.
#'   Threshold used is `ceiling(prop_present * n_repeats)`. Default `0.7`.
#' @param min_reps Optional positive integer; minimum number of repetitions
#'   (per layer) required for an edge to be kept. If provided, it overrides
#'   `prop_present`.
#' @param summary `"mean"`, `"median"`, or a function that takes a numeric vector
#'   and returns a single number. This summary is applied **across repetitions**.
#'   Default `c("mean","median")` (matched to `"mean"` unless a function is passed).
#' @param directed Logical; if `FALSE` (default) treat graphs as undirected by
#'   sorting endpoints before counting and summarising edges. If `TRUE`, treat as directed.
#' @param keep_self_loops Logical; keep `from == to` edges (`TRUE`) or drop them
#'   (`FALSE`, default).
#' @param na_rm Logical; drop `NA` values when computing the **across‑rep** weight
#'   summary. Default `TRUE`. (Note: duplicates within a repetition are always
#'   averaged by mean with `na.rm = TRUE`.)
#' @param as_list Logical; return a named list (one data frame per layer). If
#'   `FALSE`, return a single tidy data frame with a `layer` column. Default `TRUE`.
#' @param layer_col,rep_col For `data.frame` input only: column names holding the
#'   layer and repetition identifiers. If `NULL`, the function tries to auto‑detect
#'   them as described above.
#' @param save_to_rds Logical; save the result as an RDS file. Default `TRUE`.
#' @param rds_file Optional filename for the RDS. If relative, it is saved under
#'   `results_dir`; if absolute, it is used as given. Default `NULL` (auto‑named).
#' @param write_csv Logical; write CSV output(s). If `as_list = TRUE`, one file per
#'   layer is written. Default `FALSE`.
#' @param csv_prefix Basename prefix for CSV files. Default `"consensus_edges"`.
#' @param write_xlsx Logical; write an XLSX file (requires **writexl**). If
#'   `as_list = TRUE`, a multi‑sheet workbook is produced (one sheet per layer);
#'   otherwise a single‑sheet workbook is written. Default `FALSE`.
#' @param xlsx_file Optional XLSX filename; if relative, saved under `results_dir`.
#'   Default `NULL` (auto‑named).
#' @param results_dir Output directory. Default
#'   `getOption("mlnet.results_dir", "omicsDNA_results")`.
#' @param verbose Logical; print progress per layer and file save messages.
#'   Default `TRUE`.
#'
#' @return If `as_list = TRUE`, a named list of data frames (one per layer), each
#' with columns `from`, `to`, `weight`, `n_present`, `n_repeats`, `prop_present`.
#' If `as_list = FALSE`, a single tidy data frame with an additional `layer` column.
#'
#' @section Practical tips
#' - If you start from adjacencies obtained via resampling (e.g., bootstrap),
#'   pass the nested list of matrices directly; the function will label layers
#'   and repetitions deterministically from the list structure.
#' - When your repetitions are unlabelled, you can leave `rep_col` unset;
#'   the function will treat all rows as belonging to repetition `"1"`.
#'
#' @seealso \code{\link{edgesFromAdjacency}} for converting adjacency matrices to edge tables.
#' @export
consensusEdges <- function(
    edges,
    prop_present    = 0.7,
    min_reps        = NULL,
    summary         = c("mean","median"),
    directed        = FALSE,
    keep_self_loops = FALSE,
    na_rm           = TRUE,
    as_list         = TRUE,
    layer_col       = NULL,
    rep_col         = NULL,
    save_to_rds     = TRUE,
    rds_file        = NULL,
    write_csv       = FALSE,
    csv_prefix      = "consensus_edges",
    write_xlsx      = FALSE,
    xlsx_file       = NULL,
    results_dir     = getOption("mlnet.results_dir", "omicsDNA_results"),
    verbose         = TRUE
) {
  # ---- checks ----
  if (!is.numeric(prop_present) || length(prop_present) != 1L || prop_present <= 0 || prop_present > 1)
    stop("`prop_present` must be a single number in (0,1].")
  if (!is.null(min_reps) && (!is.numeric(min_reps) || min_reps < 1))
    stop("`min_reps` must be a positive integer when provided.")

  # summary function
  stat_fun <- if (is.function(summary)) {
    summary
  } else {
    summary <- match.arg(summary)
    switch(summary,
           mean   = function(x) mean(x, na.rm = na_rm),
           median = function(x) stats::median(x, na.rm = na_rm))
  }

  # ---- helpers ----
  .ensure_dir <- function(d) if (!dir.exists(d)) dir.create(d, recursive = TRUE, showWarnings = FALSE)
  .is_abs     <- function(p) grepl("^(/|[A-Za-z]:[\\/])", p)
  .sanitize   <- function(s) gsub("[^[:alnum:]_.-]+", "_", s)

  .list_depth <- function(x) if (!is.list(x) || !length(x)) 0L else 1L + max(vapply(x, .list_depth, integer(1L)))
  .first_leaf <- function(x) { if (is.list(x) && length(x)) return(.first_leaf(x[[1]])); x }

  .matrix_has_edges <- function(m) {
    if (inherits(m, "Matrix")) {
      nz  <- Matrix::nnzero(m)
      dnn <- sum(diag(m) != 0)
      (nz - dnn) > 0
    } else if (is.matrix(m)) {
      if (!length(m)) return(FALSE)
      mm <- m
      if (nrow(mm) == ncol(mm) && nrow(mm) > 0) diag(mm) <- 0
      any(mm != 0)
    } else {
      FALSE
    }
  }

  # Flatten any-depth LIST of EDGE DATA FRAMES into df with id cols level1..levelK
  # (robust to 0-row leaves)
  .flatten_edge_list_any_depth <- function(x) {
    res <- list()
    rec <- function(node, path) {
      if (is.data.frame(node)) {
        if (!all(c("from","to","weight") %in% names(node)))
          stop("All edge leaf data frames must contain columns: from, to, weight.")
        df <- data.frame(
          from   = as.character(node$from),
          to     = as.character(node$to),
          weight = as.numeric(node$weight),
          stringsAsFactors = FALSE
        )
        # attach id columns as 0-row if df is empty
        if (length(path)) {
          id_names <- paste0("level", seq_along(path))
          if (nrow(df) == 0L) {
            id_df <- as.data.frame(setNames(lapply(path, function(.) character(0)), id_names), stringsAsFactors = FALSE)
            df    <- cbind(id_df, df)
          } else {
            add   <- as.list(path); names(add) <- id_names
            df    <- cbind(as.data.frame(add, stringsAsFactors = FALSE), df)
          }
        }
        res[[length(res)+1L]] <<- df
      } else if (is.list(node) && length(node)) {
        for (i in seq_along(node)) {
          nm <- names(node)[i]; if (is.null(nm) || !nzchar(nm)) nm <- as.character(i)
          rec(node[[i]], c(path, nm))
        }
      } else if (is.matrix(node) || inherits(node, "Matrix")) {
        # treat matrices as edges via edgesFromAdjacency() at higher level; do nothing here
        stop("Unexpected adjacency matrix leaf in edge-list flattener; use adjacency flattener path.")
      } else if (!is.null(node)) {
        stop("Unsupported leaf type in list input: ", class(node)[1])
      }
    }
    rec(x, character())
    if (!length(res)) return(data.frame())
    # unify id columns across ragged branches
    idcols <- unique(unlist(lapply(res, function(df) names(df)[grepl("^level\\d+$", names(df))])))
    idcols <- idcols[order(as.integer(sub("^level", "", idcols)))]
    res <- lapply(res, function(df) {
      for (col in setdiff(idcols, names(df))) df[[col]] <- if (nrow(df)) NA_character_ else character(0)
      df[, c(idcols, "from","to","weight")]
    })
    out <- do.call(rbind, res)
    rownames(out) <- NULL
    out
  }

  # ---- Option B pre-filter for LIST inputs ----
  # Remove empty layer snapshots (per iteration) and then globally drop layers seen in <20% of iterations.
  if (is.list(edges)) {
    leaf <- .first_leaf(edges)
    if (is.data.frame(leaf) || is.matrix(leaf) || inherits(leaf, "Matrix")) {

      # Heuristic: treat top-level as iterations if it is a list of lists
      if (length(edges) > 0 && all(vapply(edges, is.list, logical(1)))) {

        iter_names <- names(edges)
        if (is.null(iter_names) || !any(nzchar(iter_names))) iter_names <- as.character(seq_len(length(edges)))

        # pass 1: remove 0-edge snapshots; track per-layer presence across iterations
        layer_presence_counts <- integer(0)

        for (i in seq_along(edges)) {
          layer_list <- edges[[i]]
          if (!is.list(layer_list)) next
          lay_names <- names(layer_list)
          if (is.null(lay_names) || !any(nzchar(lay_names))) lay_names <- as.character(seq_along(layer_list))

          for (j in seq_along(layer_list)) {
            Lname <- lay_names[j]
            leafj <- layer_list[[j]]

            is_empty <- FALSE
            if (is.data.frame(leafj)) {
              is_empty <- nrow(leafj) == 0L
            } else if (is.matrix(leafj) || inherits(leafj, "Matrix")) {
              is_empty <- !.matrix_has_edges(leafj)
            } else {
              # Unsupported leaf: drop it defensively
              is_empty <- TRUE
            }

            if (is_empty) {
              # remove this snapshot; report
              edges[[i]][[Lname]] <- NULL
              if (isTRUE(verbose)) message("Removing layer '", Lname, "' from iteration ", iter_names[i], ": 0 edges.")
            } else {
              # mark presence of this layer in this iteration
              layer_presence_counts[Lname] <- layer_presence_counts[Lname] + 1L
            }
          }
        }

        # denominator: total iterations
        n_iters_total <- length(edges)
        # threshold: <20% presence -> drop layer globally
        min_keep_global <- ceiling(0.20 * n_iters_total)
        if (length(layer_presence_counts)) {
          drop_glob <- names(layer_presence_counts)[layer_presence_counts < min_keep_global]
          if (length(drop_glob)) {
            for (i in seq_along(edges)) {
              if (is.list(edges[[i]]) && length(edges[[i]])) {
                for (nm in intersect(names(edges[[i]]), drop_glob)) {
                  edges[[i]][[nm]] <- NULL
                }
              }
            }
            if (isTRUE(verbose)) {
              for (nm in drop_glob) {
                k <- layer_presence_counts[[nm]]
                p <- if (n_iters_total > 0) round(100 * k / n_iters_total, 1) else 0
                message("Dropping layer '", nm, "' globally: present in ",
                        k, "/", n_iters_total, " iterations (", p, "% < 20%).")
              }
            }
          }
        }
      }
    }
  }

  # ---- Normalize input into tidy df with columns: layer, rep, from, to, weight ----
  to_df <- function(E) {
    # Case A: already a data.frame
    if (is.data.frame(E)) {
      if (!all(c("from","to","weight") %in% names(E)))
        stop("Data frame input must contain columns: from, to, weight.")
      # detect layer/rep columns if not provided
      lc <- layer_col
      if (is.null(lc)) {
        cand <- c("layer","Layer","group","Group")
        hit  <- cand[cand %in% names(E)][1]
        if (is.na(hit)) stop("Data frame input must have a layer column. Use `layer_col` to specify.")
        lc <- hit
      }
      rc <- rep_col
      if (is.null(rc)) {
        cand <- c("rep","repeat","repetition","bootstrap","iter","iteration","Rep","Repeat")
        hit  <- cand[cand %in% names(E)][1]
        rc   <- if (is.na(hit)) NULL else hit
      }
      out <- data.frame(
        layer  = as.character(E[[lc]]),
        rep    = if (is.null(rc)) "1" else as.character(E[[rc]]),
        from   = as.character(E$from),
        to     = as.character(E$to),
        weight = as.numeric(E$weight),
        stringsAsFactors = FALSE
      )
      return(out)
    }

    # Case B: list input
    if (is.list(E)) {
      leaf <- .first_leaf(E)
      # B1: list of adjacency matrices -> use edgesFromAdjacency() to flatten
      if (is.matrix(leaf) || inherits(leaf, "Matrix")) {
        if (!exists("edgesFromAdjacency"))
          stop("`edgesFromAdjacency()` must be available to convert adjacency matrices.")
        depth <- .list_depth(E)
        id_cols <- paste0("level", seq_len(depth))
        tmp <- edgesFromAdjacency(E, flatten = TRUE, id_cols = id_cols, save_to_rds = FALSE, verbose = FALSE)
        # last id level -> layer; others collapsed into rep
        id_cols <- grep("^level\\d+$", names(tmp), value = TRUE)
        lay_col <- tail(id_cols, 1)
        rep_cols <- setdiff(id_cols, lay_col)
        rep_str <- if (length(rep_cols)) do.call(paste, c(tmp[rep_cols], sep = "|")) else rep("1", nrow(tmp))
        return(data.frame(
          layer  = as.character(tmp[[lay_col]]),
          rep    = as.character(rep_str),
          from   = as.character(tmp$from),
          to     = as.character(tmp$to),
          weight = as.numeric(tmp$weight),
          stringsAsFactors = FALSE
        ))
      }
      # B2: list of edge data frames (any depth)
      tmp <- .flatten_edge_list_any_depth(E)
      if (!nrow(tmp)) {
        return(data.frame(layer=character(), rep=character(), from=character(), to=character(), weight=numeric(), stringsAsFactors = FALSE))
      }
      id_cols <- grep("^level\\d+$", names(tmp), value = TRUE)
      lay_col <- tail(id_cols, 1)
      rep_cols <- setdiff(id_cols, lay_col)
      rep_str <- if (length(rep_cols)) do.call(paste, c(tmp[rep_cols], sep = "|")) else rep("1", nrow(tmp))
      return(data.frame(
        layer  = as.character(tmp[[lay_col]]),
        rep    = as.character(rep_str),
        from   = as.character(tmp$from),
        to     = as.character(tmp$to),
        weight = as.numeric(tmp$weight),
        stringsAsFactors = FALSE
      ))
    }

    # Case C: single adjacency matrix
    if (is.matrix(E) || inherits(E, "Matrix")) {
      if (!exists("edgesFromAdjacency"))
        stop("`edgesFromAdjacency()` must be available to convert adjacency matrices.")
      df <- edgesFromAdjacency(E, flatten = FALSE, save_to_rds = FALSE, verbose = FALSE)
      df <- if (is.list(df)) df[[1]] else df
      return(data.frame(layer = "1", rep = "1",
                        from = as.character(df$from), to = as.character(df$to),
                        weight = as.numeric(df$weight), stringsAsFactors = FALSE))
    }

    stop("Unsupported input type for `edges`.")
  }

  df <- to_df(edges)

  # ---- normalize per (layer, rep) ----
  if (!keep_self_loops && nrow(df)) {
    df <- df[df$from != df$to, , drop = FALSE]
  }
  if (!directed && nrow(df)) {
    a <- pmin(df$from, df$to)
    b <- pmax(df$from, df$to)
    df$from <- a; df$to <- b
  }
  if (!nrow(df)) {
    empty <- data.frame(layer=character(), from=character(), to=character(), weight=numeric(),
                        n_present=integer(), n_repeats=integer(), prop_present=numeric(),
                        stringsAsFactors = FALSE)
    return(if (as_list) list() else empty)
  }

  # deduplicate within (layer, rep, from, to)
  df <- stats::aggregate(weight ~ layer + rep + from + to,
                         data = df,
                         FUN = function(z) mean(as.numeric(z), na.rm = TRUE))

  # ---- consensus per layer ----
  layers <- unique(df$layer)
  layers <- layers[order(layers)]
  result_list <- setNames(vector("list", length(layers)), layers)

  for (L in layers) {
    dL <- df[df$layer == L, , drop = FALSE]
    if (!nrow(dL)) next

    reps_in_L  <- unique(as.character(dL$rep))
    n_repeats  <- length(reps_in_L)

    # presence counts per edge across reps
    counts <- stats::aggregate(rep ~ from + to, data = dL, FUN = function(v) length(unique(v)))
    names(counts)[3] <- "n_present"

    min_keep <- if (!is.null(min_reps)) as.integer(min_reps) else max(1L, ceiling(prop_present * n_repeats))

    keep_idx <- counts$n_present >= min_keep
    if (!any(keep_idx)) {
      result_list[[L]] <- data.frame(from=character(), to=character(), weight=numeric(),
                                     n_present=integer(), n_repeats=integer(), prop_present=numeric(),
                                     stringsAsFactors = FALSE)
      if (isTRUE(verbose)) message("• Layer ", L, ": kept 0 edges (threshold = ", min_keep, " / ", n_repeats, ")")
      next
    }

    kept_keys <- counts[keep_idx, c("from","to")]
    dL_kept   <- merge(dL, kept_keys, by = c("from","to"))

    # summarize weights across repetitions
    wsum <- stats::aggregate(weight ~ from + to, data = dL_kept, FUN = stat_fun)

    outL <- merge(wsum, counts, by = c("from","to"), all.x = TRUE)
    outL$n_repeats    <- n_repeats
    outL$prop_present <- outL$n_present / outL$n_repeats
    outL <- outL[order(outL$from, outL$to), ]
    rownames(outL) <- NULL
    result_list[[L]] <- outL

    if (isTRUE(verbose)) {
      total_unique <- nrow(unique(dL[, c("from","to")]))
      message("• Layer ", L, ": kept ", nrow(outL), " / ", total_unique,
              " edges (threshold = ", min_keep, " / ", n_repeats, ")")
    }
  }

  # ---- assemble output ----
  out_obj <- if (isTRUE(as_list)) {
    result_list
  } else {
    pieces <- lapply(names(result_list), function(L) {
      d <- result_list[[L]]
      if (!nrow(d)) return(NULL)
      cbind(data.frame(layer = L, stringsAsFactors = FALSE), d)
    })
    pieces <- Filter(Negate(is.null), pieces)
    if (!length(pieces)) {
      data.frame(layer=character(), from=character(), to=character(), weight=numeric(),
                 n_present=integer(), n_repeats=integer(), prop_present=numeric(),
                 stringsAsFactors = FALSE)
    } else {
      do.call(rbind, pieces)
    }
  }

  # ---- save artifacts ----
  .ensure_dir(results_dir)
  stamp <- format(Sys.time(), "%Y-%m-%d_%H%M%S")

  if (isTRUE(save_to_rds)) {
    if (is.null(rds_file)) {
      rds_file <- if (isTRUE(as_list)) sprintf("consensus_list_%s.rds", stamp) else sprintf("consensus_df_%s.rds", stamp)
    }
    if (!.is_abs(rds_file)) rds_file <- file.path(results_dir, rds_file)
    saveRDS(out_obj, rds_file)
    if (isTRUE(verbose)) message("Saved RDS: ", normalizePath(rds_file, FALSE))
  }

  if (isTRUE(write_csv)) {
    if (isTRUE(as_list)) {
      for (L in names(out_obj)) {
        fn <- file.path(results_dir, paste0(csv_prefix, "_layer_", .sanitize(L), "_", stamp, ".csv"))
        utils::write.csv(out_obj[[L]], fn, row.names = FALSE)
      }
      if (isTRUE(verbose)) message("Saved per-layer CSVs under: ", normalizePath(results_dir, FALSE))
    } else {
      fn <- file.path(results_dir, paste0(csv_prefix, "_", stamp, ".csv"))
      utils::write.csv(out_obj, fn, row.names = FALSE)
      if (isTRUE(verbose)) message("Saved CSV: ", normalizePath(fn, FALSE))
    }
  }

  if (isTRUE(write_xlsx)) {
    if (requireNamespace("writexl", quietly = TRUE)) {
      xlsx_file <- if (is.null(xlsx_file)) {
        if (isTRUE(as_list)) file.path(results_dir, paste0("consensus_layers_", stamp, ".xlsx"))
        else                  file.path(results_dir, paste0("consensus_", stamp, ".xlsx"))
      } else if (.is_abs(xlsx_file)) xlsx_file else file.path(results_dir, xlsx_file)

      if (isTRUE(as_list)) writexl::write_xlsx(out_obj, xlsx_file)
      else                 writexl::write_xlsx(list(edges = out_obj), xlsx_file)

      if (isTRUE(verbose)) message("Saved XLSX: ", normalizePath(xlsx_file, FALSE))
    } else if (isTRUE(verbose)) {
      message("`writexl` not installed; skipping XLSX export.")
    }
  }

  out_obj
}
